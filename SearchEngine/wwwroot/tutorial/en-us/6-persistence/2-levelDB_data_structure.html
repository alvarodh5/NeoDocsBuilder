<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="format-detection" content="telephone=no" />
    <meta name="robots" content="index,follow">
    <meta name="author" content="neo-project">
    <meta name="application-name" content="neo.org">
    <meta name="renderer" content="ie-stand">
    <title>LevelDB Blockchain Data Structure</title>
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Neo Documentation" />
    <meta property="og:description" content="Neo Documentation" />
    <meta property="og:image" content="/img/twitter-img.jpg" />
    <meta name="twitter:title" content="Neo Documentation" />
    <meta name="twitter:description" content="Neo Documentation" />
    <meta name="twitter:image" content="/img/twitter-img.jpg" />
    <meta name="twitter:card" content="summary_large_image" />

    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/img/favicon-16x16.png">
    <link rel="manifest" href="/img/site.webmanifest">
    <link rel="mask-icon" href="/img/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#00aba9">
    <meta name="theme-color" content="#ffffff">

    <link href="https://neo-cdn.azureedge.net/lib/bootstrap/css/bootstrap.min.css" rel="stylesheet" />
    <link href="https://neo-cdn.azureedge.net/lib/animate.css/animate.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.8/styles/default.min.css">
    <link href="/lib/font-awesome/css/all.min.css" rel="stylesheet" />
    <link href="/css/site.min.css" rel="stylesheet" />
</head>
<body data-spy="scroll" data-target="#navbar-sidenav">
    <nav class="navbar fixed-top navbar-expand-lg py-1 px-3 px-sm-4 px-md-5">
        <a class="navbar-brand" href="https://neo.org">
            <img class="logo" src="/img/logo.svg" alt="NEO Logo" />
            <img class="logo-dark" src="/img/logo-dark.svg" alt="NEO Logo" />
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <i class="fas fa-bars"></i>
        </button>
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav ml-auto">
                <li class="nav-item">
                    <a class="nav-link" href="/docs">Documentation</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="/tutorial">Tutorial</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="/faq">FAQ</a>
                </li>
                <li class="nav-item" style="margin-right: 100px">
                    <a class="nav-link" href="/articles">Articles</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link d-inline-block" href="javascript:" onclick="language('en-us')">EN</a>|<a class="nav-link d-inline-block" href="javascript:" onclick="language('zh-cn')">中文</a>
                </li>
            </ul>
            <form class="form-inline my-2 my-lg-0 d-none">
                <input class="form-control mr-sm-2" type="search" placeholder="Search" aria-label="Search">
                <button class="btn btn-outline-success my-2 my-sm-0" type="submit">Search</button>
            </form>
        </div>
    </nav>
    <div class="container-fluid" style="margin-top: 55px">
        <div class="row d-flex">
            <div class="d-none d-md-block catalog py-2 py-md-5 pl-md-3">
                
<nav class='nav nav-pills flex-column ml-3'>
<span class='ml-0 my-1 nav-link'><i class='fas fa-caret-right'></i>Introduction to NEO</span>
<nav class='nav nav-pills flex-column ml-3'>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/1-introduction/1-Introduction_to_NEO.html'>Introduction</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/1-introduction/2-Cryptography_Blockchain_and_Smart_Contracts.html'>Cryptography, Blockchain, and Smart Contracts</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/1-introduction/3-Fundamentals_of_NEO.html'>NEO Fundamentals</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/1-introduction/resource.html'>Additional Resources</a>
</nav>
<span class='ml-0 my-1 nav-link'><i class='fas fa-caret-right'></i>Wallet</span>
<nav class='nav nav-pills flex-column ml-3'>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/2-wallet/1-Introduction_to_wallets.html'>Introduction</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/2-wallet/2-Key_derivation_and_address_generation_on_NEO.html'>Keys and Addresses</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/2-wallet/3-Key_encryption_and_contract_accounts.html'>Private key encryption and Wallet files</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/2-wallet/4-UTXO_and_account_models.html'>The UTXO and Account models</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/2-wallet/resource.html'>Additional Resources</a>
</nav>
<span class='ml-0 my-1 nav-link'><i class='fas fa-caret-right'></i>Transactions</span>
<nav class='nav nav-pills flex-column ml-3'>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/3-transactions/1-Introduction_to_transactions.html'>Introduction</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/3-transactions/2-Structure_of_NEO_transactions.html'>Structure of NEO transactions</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/3-transactions/3-NEO_transaction_types.html'>NEO transaction types</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/3-transactions/4-NEO_transaction_fees.html'>Transaction fees</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/3-transactions/resource.html'>Additional Resources</a>
</nav>
<span class='ml-0 my-1 nav-link'><i class='fas fa-caret-right'></i>Blocks</span>
<nav class='nav nav-pills flex-column ml-3'>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/4-blocks/1-Introduction_to_blocks_and_blockchain.html'>Introduction</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/4-blocks/2-Structure_of_a_block.html'>Structure of a Block</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/4-blocks/3-Block_creation_broadcasting.html'>Block Creation and Broadcasting</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/4-blocks/4-Block_validation_processing.html'>Block Validation and Processing</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/4-blocks/resource.html'>Additional Resources</a>
</nav>
<span class='ml-0 my-1 nav-link'><i class='fas fa-caret-right'></i>Network</span>
<nav class='nav nav-pills flex-column ml-3'>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/5-network/1-Introduction_to_the_NEO_network_protocol.html'>NEO Network and Protocol</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/5-network/resource.html'>Additional Resources</a>
</nav>
<span class='ml-0 my-1 nav-link'><i class='fas fa-caret-right'></i>Persistence</span>
<nav class='nav nav-pills flex-column ml-3'>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/6-persistence/1-persistence.html'>Introduction</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/6-persistence/2-levelDB_data_structure.html'>Developing a NEO Ping using Golang</a>
</nav>
<span class='ml-0 my-1 nav-link'><i class='fas fa-caret-right'></i>Consensus</span>
<nav class='nav nav-pills flex-column ml-3'>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/7-consensus/1-Introduction_to_consensus.html'>Introduction</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/7-consensus/2-Proof_of_work_and_proof_of_stake.html'>PoW and PoS</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/7-consensus/3-PBFT_and_DBFT.html'>pBFT and dBFT</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/7-consensus/4-Examples_and_consensus_scenarios_for_dBFT.html'>dBFT Consensus Examples and Scenarios</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/7-consensus/resource.html'>Additional Resources</a>
</nav>
<span class='ml-0 my-1 nav-link'><i class='fas fa-caret-right'></i>Smart Contract</span>
<nav class='nav nav-pills flex-column ml-3'>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/9-smartContract/What_is_smart_contract.html'>Introduction</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/9-smartContract/Development_privateChain.html'>Setting up a Private Chain</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/9-smartContract/Development_set_up.html'>Setting up Development Enviroment</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/9-smartContract/Development_compile.html'>Contract Invoking and Deployment</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/9-smartContract/Smart_Contract_basics.html'>Smart Contract Basics</a>
<span class='ml-0 my-1 nav-link'><i class='fas fa-caret-right'></i>Make your NEP-5 Token</span>
<nav class='nav nav-pills flex-column ml-3'>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/9-smartContract/What_is_nep5.html'>Introduction to NEP-5</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/9-smartContract/Implementation_of_NEP5.html'>Implementation of NEP-5</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/9-smartContract/Give_an_ITO.html'>ITO(Initial Token Offering)</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/9-smartContract/UTXO.html'>UTXO basics</a>
</nav>
<span class='ml-0 my-1 nav-link'><i class='fas fa-caret-right'></i>CGAS</span>
<nav class='nav nav-pills flex-column ml-3'>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/9-smartContract/cgas/1_what_is_cgas.html'>What is CGAS</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/9-smartContract/cgas/2_global_asset_and_nep5.html'>Global asset and NEP-5</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/9-smartContract/cgas/3_utxo_model.html'>UTXO model</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/9-smartContract/cgas/4_trigger.html'>Trigger</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/9-smartContract/cgas/5_minttokens_and_refund.html'>Mint and Refund</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/9-smartContract/cgas/6_signature_and_verification.html'>Signature and Verification</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/9-smartContract/cgas/7_invocation.html'>Transaction Invocation</a>
</nav>
<span class='ml-0 my-1 nav-link'><i class='fas fa-caret-right'></i>Write NEO smart contract with Python</span>
<nav class='nav nav-pills flex-column ml-3'>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/9-smartContract/neopython/part1_setup.html'>Installing and Setting up the Environment</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/en-us/9-smartContract/neopython/part2_neopy.html'>Wallet Operations and Smart Contracts</a>
</nav>
</nav>
</nav>
            </div>
            <main class="p-3 p-sm-4 p-md-5">
                <a class="d-block d-md-none" href="javascript:" onclick="showCatalog()">Show / Hide Table of Contents</a>
                <h1 id='d5d1991e'><span class='with-space bd-content-title'>LevelDB Blockchain Data Structure<a class='anchorjs-link ' href='#d5d1991e' aria-label='Anchor' data-anchorjs-icon='#'></a></span></h1>
<p class='with-space'>The current implementation of NEO in C# uses LevelDB, a fast key-value database, to persist blockchain information. This DB is used for both system data, like blocks and transactions, but also for smart contract data.
When the node receives a message that triggers a change in state (like a new block or header), it retrieves and updates a snapshot, commiting its results when the operation is done. 
Below we have a simplified example of how this is happens:</p>
<p class='with-space'><img class='d-inline-block img-fluid' data-original='persistence_snapshot.png' alt='snapshot' referrerPolicy='no-referrer' /></p>
<h2 id='d8ea9052'><span class='with-space bd-content-title'>LevelDB Table Structure<a class='anchorjs-link ' href='#d8ea9052' aria-label='Anchor' data-anchorjs-icon='#'></a></span></h2>
<p class='with-space'>The data is stored using the structured provided by the classes from the <a href='https://github.com/neo-project/neo/tree/master-2.x/neo/Ledger' target='_blank'> Ledger</a> package. Using a <code>prefix</code> to separate each &#39;table&#39;.</p>
<p class='with-space'>We can see here the prefixes used in neo (C#):</p>
<figure class='with-space'><table class='table table-hover'>
<thead><tr><th style='text-align:left;'>Prefix</th><th style='text-align:left;'>Description</th><th style='text-align:left;'>LevelDB Key</th><th style='text-align:left;'>Level DB Value</th></tr></thead>
<tbody><tr><td style='text-align:left;'>0x01</td><td style='text-align:left;'> <strong>Block</strong> : Block header prepended with <code>system fee</code> </td><td style='text-align:left;'>Block Hash</td><td style='text-align:left;'> <a href='https://github.com/neo-project/neo/blob/master-2.x/neo/Ledger/BlockState.cs' target='_blank'> BlockState</a> </td></tr><tr><td style='text-align:left;'>0x02</td><td style='text-align:left;'> <strong>Transaction</strong> : Transaction prepended with <code>block index</code> </td><td style='text-align:left;'>Transaction Hash</td><td style='text-align:left;'> <a href='https://github.com/neo-project/neo/blob/master-2.x/neo/Ledger/TransactionState.cs' target='_blank'> TransactonState</a> </td></tr><tr><td style='text-align:left;'>0x40</td><td style='text-align:left;'> <strong>Account</strong> : account meta-data (votes, balances)</td><td style='text-align:left;'>Account Script Hash</td><td style='text-align:left;'> <a href='https://github.com/neo-project/neo/blob/master-2.x/neo/Ledger/AccountState.cs' target='_blank'> AccountState</a> </td></tr><tr><td style='text-align:left;'>0x44</td><td style='text-align:left;'> <strong>Unspent Coins</strong> : Transactions that can be used as input in another transaction</td><td style='text-align:left;'>Transaction Hash</td><td style='text-align:left;'> <a href='https://github.com/neo-project/neo/blob/master-2.x/neo/Ledger/UnspentCoinState.cs' target='_blank'> UnspentCoinState</a> </td></tr><tr><td style='text-align:left;'>0x45</td><td style='text-align:left;'> <strong>Spent Coins</strong> : Transactions used as input in a previous transaction (spent)</td><td style='text-align:left;'>Transaction Hash</td><td style='text-align:left;'> <a href='https://github.com/neo-project/neo/blob/master-2.x/neo/Ledger/SpentCoinState.cs' target='_blank'> SpentCoinState</a> </td></tr><tr><td style='text-align:left;'>0x48</td><td style='text-align:left;'> <strong>Validators</strong> : Network Validators meta-data</td><td style='text-align:left;'>Validator Public Key</td><td style='text-align:left;'> <a href='https://github.com/neo-project/neo/blob/master-2.x/neo/Ledger/ValidatorState.cs' target='_blank'> ValidatorState</a> </td></tr><tr><td style='text-align:left;'>0x4c</td><td style='text-align:left;'> <strong>Assets</strong> : Native coins meta-data</td><td style='text-align:left;'>Register Transaction Hash</td><td style='text-align:left;'> <a href='https://github.com/neo-project/neo/blob/master-2.x/neo/Ledger/AssetState.cs' target='_blank'> AssetState</a> </td></tr><tr><td style='text-align:left;'>0x50</td><td style='text-align:left;'> <strong>Contracts</strong> : Contract meta-data</td><td style='text-align:left;'>Contract Script Hash</td><td style='text-align:left;'> <a href='https://github.com/neo-project/neo/blob/master-2.x/neo/Ledger/ContractState.cs' target='_blank'> ContractState</a> </td></tr><tr><td style='text-align:left;'>0x70</td><td style='text-align:left;'> <strong>Smart Contract Storage</strong> : Storage used by SmartContracts</td><td style='text-align:left;'>ScriptHash + Key</td><td style='text-align:left;'>Byte[]</td></tr><tr><td style='text-align:left;'>0x80</td><td style='text-align:left;'> <strong>Pending Headers</strong> : Used in synchronization to track blocks waiting to be synced</td><td style='text-align:left;'>Prefix only</td><td style='text-align:left;'> <a href='https://github.com/neo-project/neo/blob/master-2.x/neo/Ledger/HeaderHashList.cs' target='_blank'> HeaderHashList</a> </td></tr><tr><td style='text-align:left;'>0x90</td><td style='text-align:left;'> <strong>Validators Count</strong> : Used for recording the votes of the consensus nodes to be selected</td><td style='text-align:left;'>Prefix only</td><td style='text-align:left;'> <a href='https://github.com/neo-project/neo/blob/master-2.x/neo/Ledger/ValidatorsCountState.cs' target='_blank'> ValidatorsCountState</a> </td></tr><tr><td style='text-align:left;'>0xc0</td><td style='text-align:left;'> <strong>Current block</strong> : Last commited block</td><td style='text-align:left;'>Prefix only</td><td style='text-align:left;'> <a href='[HashIndexState](https://github.com/neo-project/neo/blob/master-2.x/neo/Ledger/HashIndexState.cs)'> HashIndexState</a> </td></tr><tr><td style='text-align:left;'>0xc1</td><td style='text-align:left;'> <strong>Current header</strong> : Block under synchronization</td><td style='text-align:left;'>Prefix only</td><td style='text-align:left;'> <a href='[HashIndexState](https://github.com/neo-project/neo/blob/master-2.x/neo/Ledger/HashIndexState.cs)'> HashIndexState</a> </td></tr><tr><td style='text-align:left;'>0xf0</td><td style='text-align:left;'> <strong>System version</strong> : Current system version. Used to prevent data inconsistency</td><td style='text-align:left;'>Prefix only</td><td style='text-align:left;'>String (&quot;2.9.2&quot;)</td></tr>
</tbody>
</table></figure>
<p class='with-space'><em>Prefixes 0xf1 to 0xff are reserved for external use.</em></p>
<p class='with-space'>The prefixes can be found <a href='https://github.com/neo-project/neo/blob/master/neo/Persistence/LevelDB/Prefixes.cs' target='_blank'> here</a> .</p>
<h3 id='f1722025'><span class='with-space bd-content-title'>Memory Pool<a class='anchorjs-link ' href='#f1722025' aria-label='Anchor' data-anchorjs-icon='#'></a></span></h3>
<p class='with-space'>The memory pool is a collection in memory used to track transactions that are not yet committed/persisted. When looking for a transaction, the node will always check first if the transaction is in the memory pool, before checking the device storage.</p>
<p class='with-space'><img class='d-inline-block img-fluid' data-original='persistence_memory_pool_1.png' alt='memory_pool_1' referrerPolicy='no-referrer' /></p>
<p class='with-space'>If the <code>Storage</code> returns a null transaction, either the transaction does not exist (if the node is fully synchronized), or the transaction must be retrieved from other nodes.</p>
<h3 id='fad32880'><span class='with-space bd-content-title'>0x01 - Blocks<a class='anchorjs-link ' href='#fad32880' aria-label='Anchor' data-anchorjs-icon='#'></a></span></h3>
<figure class='highlight'>
<button type='button' class='btn-clipboard' data-original-title='Copy to clipboard' data-clipboard-action='copy' data-toggle='tooltip' data-placement='top' title='Copy to clipboard' data-clipboard-text='private void OnNewHeaders(Header[] headers)
        {
            using (Snapshot snapshot = GetSnapshot())
            {
                foreach (Header header in headers)
                {
                    if (header.Index - 1 &gt;= header_index.Count) break;
                    if (header.Index &lt; header_index.Count) continue;
                    if (!header.Verify(snapshot)) break;
                    header_index.Add(header.Hash);
                    snapshot.Blocks.Add(header.Hash, new BlockState
                    {
                        SystemFeeAmount = 0,
                        TrimmedBlock = header.Trim()
                    });
                    snapshot.HeaderHashIndex.GetAndChange().Hash = header.Hash;
                    snapshot.HeaderHashIndex.GetAndChange().Index = header.Index;
                }
                SaveHeaderHashList(snapshot);
                snapshot.Commit();
            }
            UpdateCurrentSnapshot();
            system.TaskManager.Tell(new TaskManager.HeaderTaskCompleted(), Sender);
        }'>Copy</button><pre><code class='csharp' lang='csharp'>private void OnNewHeaders(Header[] headers)
        {
            using (Snapshot snapshot = GetSnapshot())
            {
                foreach (Header header in headers)
                {
                    if (header.Index - 1 &gt;= header_index.Count) break;
                    if (header.Index &lt; header_index.Count) continue;
                    if (!header.Verify(snapshot)) break;
                    header_index.Add(header.Hash);
                    snapshot.Blocks.Add(header.Hash, new BlockState
                    {
                        SystemFeeAmount = 0,
                        TrimmedBlock = header.Trim()
                    });
                    snapshot.HeaderHashIndex.GetAndChange().Hash = header.Hash;
                    snapshot.HeaderHashIndex.GetAndChange().Index = header.Index;
                }
                SaveHeaderHashList(snapshot);
                snapshot.Commit();
            }
            UpdateCurrentSnapshot();
            system.TaskManager.Tell(new TaskManager.HeaderTaskCompleted(), Sender);
        }
</code></pre>
</figure>
<p class='with-space'> <strong>Important note</strong> : The <code>block</code> that is returned to external peers through the network is called <code>trimmed block</code> at persistence level.</p>
<figure class='highlight'>
<button type='button' class='btn-clipboard' data-original-title='Copy to clipboard' data-clipboard-action='copy' data-toggle='tooltip' data-placement='top' title='Copy to clipboard' data-clipboard-text='public static bool ContainsBlock(this IPersistence persistence, UInt256 hash)
{
  BlockState state = persistence.Blocks.TryGet(hash);
  if (state == null) return false;
    return state.TrimmedBlock.IsBlock;
}

 public bool IsBlock =&gt; Hashes.Length &gt; 0;'>Copy</button><pre><code class='csharp' lang='csharp'>public static bool ContainsBlock(this IPersistence persistence, UInt256 hash)
{
  BlockState state = persistence.Blocks.TryGet(hash);
  if (state == null) return false;
    return state.TrimmedBlock.IsBlock;
}

 public bool IsBlock =&gt; Hashes.Length &gt; 0;
</code></pre>
</figure>
<h3 id='df1547df'><span class='with-space bd-content-title'>0x02 - Transactions<a class='anchorjs-link ' href='#df1547df' aria-label='Anchor' data-anchorjs-icon='#'></a></span></h3>
<p class='with-space'>All transactions are stored under the Transactions prefix. The transactions are added individually by the consensus nodes and then committed in one block, these can be retrieved individually or in batches.</p>
<figure class='highlight'>
<button type='button' class='btn-clipboard' data-original-title='Copy to clipboard' data-clipboard-action='copy' data-toggle='tooltip' data-placement='top' title='Copy to clipboard' data-clipboard-text='private bool AddTransaction(Transaction tx, bool verify)
{
      if (verify &amp;&amp; !tx.Verify(context.Snapshot, context.Transactions.Values))
      {
          Log($&quot;Invalid transaction: {tx.Hash}{Environment.NewLine}{tx.ToArray().ToHexString()}&quot;, LogLevel.Warning);
          RequestChangeView();
          return false;
      }
      if (!Plugin.CheckPolicy(tx))
      {
          Log($&quot;reject tx: {tx.Hash}{Environment.NewLine}{tx.ToArray().ToHexString()}&quot;, LogLevel.Warning);
          RequestChangeView();
          return false;
      }
      context.Transactions[tx.Hash] = tx;
      if (context.TransactionHashes.Length == context.Transactions.Count)
      {
          if (VerifyRequest())
          {
              // if we are the primary for this view, but acting as a backup because we recovered our own
              // previously sent prepare request, then we don&#39;t want to send a prepare response.
              if (context.IsPrimary() || context.WatchOnly()) return true;

              // Timeout extension due to prepare response sent
              // around 2*15/M=30.0/5 ~ 40% block time (for M=5)
              ExtendTimerByFactor(2);

              Log($&quot;send prepare response&quot;);
              localNode.Tell(new LocalNode.SendDirectly { Inventory = context.MakePrepareResponse() });
              CheckPreparations();
          }
          else
          {
              RequestChangeView();
              return false;
          }
      }
      return true;
  }'>Copy</button><pre><code class='csharp' lang='csharp'>private bool AddTransaction(Transaction tx, bool verify)
{
      if (verify &amp;&amp; !tx.Verify(context.Snapshot, context.Transactions.Values))
      {
          Log($&quot;Invalid transaction: {tx.Hash}{Environment.NewLine}{tx.ToArray().ToHexString()}&quot;, LogLevel.Warning);
          RequestChangeView();
          return false;
      }
      if (!Plugin.CheckPolicy(tx))
      {
          Log($&quot;reject tx: {tx.Hash}{Environment.NewLine}{tx.ToArray().ToHexString()}&quot;, LogLevel.Warning);
          RequestChangeView();
          return false;
      }
      context.Transactions[tx.Hash] = tx;
      if (context.TransactionHashes.Length == context.Transactions.Count)
      {
          if (VerifyRequest())
          {
              // if we are the primary for this view, but acting as a backup because we recovered our own
              // previously sent prepare request, then we don&#39;t want to send a prepare response.
              if (context.IsPrimary() || context.WatchOnly()) return true;

              // Timeout extension due to prepare response sent
              // around 2*15/M=30.0/5 ~ 40% block time (for M=5)
              ExtendTimerByFactor(2);

              Log($&quot;send prepare response&quot;);
              localNode.Tell(new LocalNode.SendDirectly { Inventory = context.MakePrepareResponse() });
              CheckPreparations();
          }
          else
          {
              RequestChangeView();
              return false;
          }
      }
      return true;
  }
</code></pre>
</figure>
<h3 id='e5652612'><span class='with-space bd-content-title'>0x40 - Accounts<a class='anchorjs-link ' href='#e5652612' aria-label='Anchor' data-anchorjs-icon='#'></a></span></h3>
<p class='with-space'>NEO uses this collection to track user balance, but without tracking UTXO.</p>
<h3 id='e923aea4'><span class='with-space bd-content-title'>0x44 - (Unspent) Coins collections<a class='anchorjs-link ' href='#e923aea4' aria-label='Anchor' data-anchorjs-icon='#'></a></span></h3>
<p class='with-space'>A transaction is considered &quot;unspent&quot; if this it is not referenced as input by some transaction. The node keeps track of these unspent coins to validate transactions but doesn&#39;t group it by account, meaning it can determine if a coin is spendable, but it cannot get all spendable coins for a specific account. The role of tracking the spendable coins by account is done by the wallet or an indexer service like <a href='neoscan.io'> neoscan</a> or <a href='neotracker.io'> neotracker</a> .</p>
<p class='with-space'>This collection is used to determine if the coin is spendable. Here is how it&#39;s done in C#:</p>
<figure class='highlight'>
<button type='button' class='btn-clipboard' data-original-title='Copy to clipboard' data-clipboard-action='copy' data-toggle='tooltip' data-placement='top' title='Copy to clipboard' data-clipboard-text='public static bool IsDoubleSpend(this IPersistence persistence, Transaction tx)
{
  if (tx.Inputs.Length == 0) return false;
    foreach (var group in tx.Inputs.GroupBy(p =&gt; p.PrevHash))
    {
      UnspentCoinState state = persistence.UnspentCoins.TryGet(group.Key);
      if (state == null) return true;
      if (group.Any(p =&gt; p.PrevIndex &gt;= state.Items.Length || state.Items[p.PrevIndex].HasFlag(CoinState.Spent)))
        return true;
      }
  return false;
}'>Copy</button><pre><code class='csharp' lang='csharp'>public static bool IsDoubleSpend(this IPersistence persistence, Transaction tx)
{
  if (tx.Inputs.Length == 0) return false;
    foreach (var group in tx.Inputs.GroupBy(p =&gt; p.PrevHash))
    {
      UnspentCoinState state = persistence.UnspentCoins.TryGet(group.Key);
      if (state == null) return true;
      if (group.Any(p =&gt; p.PrevIndex &gt;= state.Items.Length || state.Items[p.PrevIndex].HasFlag(CoinState.Spent)))
        return true;
      }
  return false;
}
</code></pre>
</figure>
<p class='with-space'>Note that at this moment, we are not checking the memory pool. This is done before the <code>IsDoubleSpend</code> check.</p>
<h3 id='abae2fef'><span class='with-space bd-content-title'>0x45 - Spent Coins<a class='anchorjs-link ' href='#abae2fef' aria-label='Anchor' data-anchorjs-icon='#'></a></span></h3>
<p class='with-space'>NEO tracks the spent coins in order to allow users to <code>claim GAS</code> . The claimable GAS is calculated based on interval of blocks between the block where the transaction was created to the moment it is spent. 
This means that, to be able to Claim GAS, you need to use that transaction. It is common to send it to yourself to &quot;unlock&quot; the claimable GAS.</p>
<figure class='highlight'>
<button type='button' class='btn-clipboard' data-original-title='Copy to clipboard' data-clipboard-action='copy' data-toggle='tooltip' data-placement='top' title='Copy to clipboard' data-clipboard-text='public Dictionary&lt;ushort, SpentCoin&gt; GetUnclaimed(UInt256 hash)
        {
    TransactionState tx_state = Transactions.TryGet(hash);
    if (tx_state == null) return null;
    SpentCoinState coin_state = SpentCoins.TryGet(hash);
    if (coin_state != null)
    {
        return coin_state.Items.ToDictionary(p =&gt; p.Key, p =&gt; new SpentCoin
        {
            Output = tx_state.Transaction.Outputs[p.Key],
            StartHeight = tx_state.BlockIndex,
            EndHeight = p.Value
        });
    }
    else
    {
        return new Dictionary&lt;ushort, SpentCoin&gt;();
    }
}'>Copy</button><pre><code class='csharp' lang='csharp'>public Dictionary&lt;ushort, SpentCoin&gt; GetUnclaimed(UInt256 hash)
        {
    TransactionState tx_state = Transactions.TryGet(hash);
    if (tx_state == null) return null;
    SpentCoinState coin_state = SpentCoins.TryGet(hash);
    if (coin_state != null)
    {
        return coin_state.Items.ToDictionary(p =&gt; p.Key, p =&gt; new SpentCoin
        {
            Output = tx_state.Transaction.Outputs[p.Key],
            StartHeight = tx_state.BlockIndex,
            EndHeight = p.Value
        });
    }
    else
    {
        return new Dictionary&lt;ushort, SpentCoin&gt;();
    }
}
</code></pre>
</figure>
<h3 id='a1c40fdc'><span class='with-space bd-content-title'>0x48 - Validators<a class='anchorjs-link ' href='#a1c40fdc' aria-label='Anchor' data-anchorjs-icon='#'></a></span></h3>
<p class='with-space'>This collection is used to verify a block, since it is required to know the validators public keys in order to validate the multiple signatures contained in a block.</p>
<figure class='highlight'>
<button type='button' class='btn-clipboard' data-original-title='Copy to clipboard' data-clipboard-action='copy' data-toggle='tooltip' data-placement='top' title='Copy to clipboard' data-clipboard-text='private void Fill()
        {
            IEnumerable&lt;Transaction&gt; memoryPoolTransactions = Blockchain.Singleton.MemPool.GetSortedVerifiedTransactions();
            foreach (IPolicyPlugin plugin in Plugin.Policies)
                memoryPoolTransactions = plugin.FilterForBlock(memoryPoolTransactions);
            List&lt;Transaction&gt; transactions = memoryPoolTransactions.ToList();
            Fixed8 amountNetFee = Block.CalculateNetFee(transactions);
            TransactionOutput[] outputs = amountNetFee == Fixed8.Zero ? new TransactionOutput[0] : new[] { new TransactionOutput
            {
                AssetId = Blockchain.UtilityToken.Hash,
                Value = amountNetFee,
                ScriptHash = wallet.GetChangeAddress()
            } };
            while (true)
            {
                ulong nonce = GetNonce();
                MinerTransaction tx = new MinerTransaction
                {
                    Nonce = (uint)(nonce % (uint.MaxValue + 1ul)),
                    Attributes = new TransactionAttribute[0],
                    Inputs = new CoinReference[0],
                    Outputs = outputs,
                    Witnesses = new Witness[0]
                };
                if (!Snapshot.ContainsTransaction(tx.Hash))
                {
                    Nonce = nonce;
                    transactions.Insert(0, tx);
                    break;
                }
            }
            TransactionHashes = transactions.Select(p =&gt; p.Hash).ToArray();
            Transactions = transactions.ToDictionary(p =&gt; p.Hash);
            NextConsensus = Blockchain.GetConsensusAddress(Snapshot.GetValidators(transactions).ToArray());
            Timestamp = Math.Max(TimeProvider.Current.UtcNow.ToTimestamp(), this.PrevHeader().Timestamp + 1);
        }'>Copy</button><pre><code class='csharp' lang='csharp'>private void Fill()
        {
            IEnumerable&lt;Transaction&gt; memoryPoolTransactions = Blockchain.Singleton.MemPool.GetSortedVerifiedTransactions();
            foreach (IPolicyPlugin plugin in Plugin.Policies)
                memoryPoolTransactions = plugin.FilterForBlock(memoryPoolTransactions);
            List&lt;Transaction&gt; transactions = memoryPoolTransactions.ToList();
            Fixed8 amountNetFee = Block.CalculateNetFee(transactions);
            TransactionOutput[] outputs = amountNetFee == Fixed8.Zero ? new TransactionOutput[0] : new[] { new TransactionOutput
            {
                AssetId = Blockchain.UtilityToken.Hash,
                Value = amountNetFee,
                ScriptHash = wallet.GetChangeAddress()
            } };
            while (true)
            {
                ulong nonce = GetNonce();
                MinerTransaction tx = new MinerTransaction
                {
                    Nonce = (uint)(nonce % (uint.MaxValue + 1ul)),
                    Attributes = new TransactionAttribute[0],
                    Inputs = new CoinReference[0],
                    Outputs = outputs,
                    Witnesses = new Witness[0]
                };
                if (!Snapshot.ContainsTransaction(tx.Hash))
                {
                    Nonce = nonce;
                    transactions.Insert(0, tx);
                    break;
                }
            }
            TransactionHashes = transactions.Select(p =&gt; p.Hash).ToArray();
            Transactions = transactions.ToDictionary(p =&gt; p.Hash);
            NextConsensus = Blockchain.GetConsensusAddress(Snapshot.GetValidators(transactions).ToArray());
            Timestamp = Math.Max(TimeProvider.Current.UtcNow.ToTimestamp(), this.PrevHeader().Timestamp + 1);
        }
</code></pre>
</figure>
<h3 id='e6097367'><span class='with-space bd-content-title'>0x4c - (Native) Assets<a class='anchorjs-link ' href='#e6097367' aria-label='Anchor' data-anchorjs-icon='#'></a></span></h3>
<p class='with-space'>This collection has information about native assets registered using the <strong>Register Transaction</strong> to allow or deny <strong>Issue Transactions</strong> .
This collection is also used by wallets to retrieve token information (name, symbol, etc.).</p>
<p class='with-space'>This collection is not deprecated yet, however, with plans of moving native assets to NEP-5 like contracts, there is a chance this collection becomes depreciated in the near future.</p>
<p class='with-space'>At code level, we can see that the Asset information is used to do additional verifications:</p>
<figure class='highlight'>
<button type='button' class='btn-clipboard' data-original-title='Copy to clipboard' data-clipboard-action='copy' data-toggle='tooltip' data-placement='top' title='Copy to clipboard' data-clipboard-text='public virtual bool Verify(Snapshot snapshot, IEnumerable&lt;Transaction&gt; mempool)
{
    if (Size &gt; MaxTransactionSize) return false;
    for (int i = 1; i &lt; Inputs.Length; i++)
        for (int j = 0; j &lt; i; j++)
                if (Inputs[i].PrevHash == Inputs[j].PrevHash &amp;&amp; Inputs[i].PrevIndex == Inputs[j].PrevIndex)
                        return false;
    if (mempool.Where(p =&gt; p != this).SelectMany(p =&gt; p.Inputs).Intersect(Inputs).Count() &gt; 0)
        return false;
    if (snapshot.IsDoubleSpend(this))
        return false;
    foreach (var group in Outputs.GroupBy(p =&gt; p.AssetId))
    {
        AssetState asset = snapshot.Assets.TryGet(group.Key);
        if (asset == null) return false;
        if (asset.Expiration &lt;= snapshot.Height + 1 &amp;&amp; asset.AssetType != AssetType.GoverningToken &amp;&amp; asset.AssetType != AssetType.UtilityToken)
            return false;
        foreach (TransactionOutput output in group)
            if (output.Value.GetData() % (long)Math.Pow(10, 8 - asset.Precision) != 0)
                return false;
    }
    TransactionResult[] results = GetTransactionResults()?.ToArray();
    if (results == null) return false;
    TransactionResult[] results_destroy = results.Where(p =&gt; p.Amount &gt; Fixed8.Zero).ToArray();
    if (results_destroy.Length &gt; 1) return false;
    if (results_destroy.Length == 1 &amp;&amp; results_destroy[0].AssetId != Blockchain.UtilityToken.Hash)
        return false;
    if (SystemFee &gt; Fixed8.Zero &amp;&amp; (results_destroy.Length == 0 || results_destroy[0].Amount &lt; SystemFee))
        return false;
    TransactionResult[] results_issue = results.Where(p =&gt; p.Amount &lt; Fixed8.Zero).ToArray();
    switch (Type)
    {
        case TransactionType.MinerTransaction:
        case TransactionType.ClaimTransaction:
            if (results_issue.Any(p =&gt; p.AssetId != Blockchain.UtilityToken.Hash))
                return false;
            break;
        case TransactionType.IssueTransaction:
            if (results_issue.Any(p =&gt; p.AssetId == Blockchain.UtilityToken.Hash))
                return false;
            break;
        default:
            if (results_issue.Length &gt; 0)
                return false;
            break;
    }
    if (Attributes.Count(p =&gt; p.Usage == TransactionAttributeUsage.ECDH02 || p.Usage == TransactionAttributeUsage.ECDH03) &gt; 1)
        return false;
    if (!VerifyReceivingScripts()) return false;
    return this.VerifyWitnesses(snapshot);
}'>Copy</button><pre><code class='csharp' lang='csharp'>public virtual bool Verify(Snapshot snapshot, IEnumerable&lt;Transaction&gt; mempool)
{
    if (Size &gt; MaxTransactionSize) return false;
    for (int i = 1; i &lt; Inputs.Length; i++)
        for (int j = 0; j &lt; i; j++)
                if (Inputs[i].PrevHash == Inputs[j].PrevHash &amp;&amp; Inputs[i].PrevIndex == Inputs[j].PrevIndex)
                        return false;
    if (mempool.Where(p =&gt; p != this).SelectMany(p =&gt; p.Inputs).Intersect(Inputs).Count() &gt; 0)
        return false;
    if (snapshot.IsDoubleSpend(this))
        return false;
    foreach (var group in Outputs.GroupBy(p =&gt; p.AssetId))
    {
        AssetState asset = snapshot.Assets.TryGet(group.Key);
        if (asset == null) return false;
        if (asset.Expiration &lt;= snapshot.Height + 1 &amp;&amp; asset.AssetType != AssetType.GoverningToken &amp;&amp; asset.AssetType != AssetType.UtilityToken)
            return false;
        foreach (TransactionOutput output in group)
            if (output.Value.GetData() % (long)Math.Pow(10, 8 - asset.Precision) != 0)
                return false;
    }
    TransactionResult[] results = GetTransactionResults()?.ToArray();
    if (results == null) return false;
    TransactionResult[] results_destroy = results.Where(p =&gt; p.Amount &gt; Fixed8.Zero).ToArray();
    if (results_destroy.Length &gt; 1) return false;
    if (results_destroy.Length == 1 &amp;&amp; results_destroy[0].AssetId != Blockchain.UtilityToken.Hash)
        return false;
    if (SystemFee &gt; Fixed8.Zero &amp;&amp; (results_destroy.Length == 0 || results_destroy[0].Amount &lt; SystemFee))
        return false;
    TransactionResult[] results_issue = results.Where(p =&gt; p.Amount &lt; Fixed8.Zero).ToArray();
    switch (Type)
    {
        case TransactionType.MinerTransaction:
        case TransactionType.ClaimTransaction:
            if (results_issue.Any(p =&gt; p.AssetId != Blockchain.UtilityToken.Hash))
                return false;
            break;
        case TransactionType.IssueTransaction:
            if (results_issue.Any(p =&gt; p.AssetId == Blockchain.UtilityToken.Hash))
                return false;
            break;
        default:
            if (results_issue.Length &gt; 0)
                return false;
            break;
    }
    if (Attributes.Count(p =&gt; p.Usage == TransactionAttributeUsage.ECDH02 || p.Usage == TransactionAttributeUsage.ECDH03) &gt; 1)
        return false;
    if (!VerifyReceivingScripts()) return false;
    return this.VerifyWitnesses(snapshot);
}
</code></pre>
</figure>
<h3 id='fc8a79f9'><span class='with-space bd-content-title'>0x50 - Contract<a class='anchorjs-link ' href='#fc8a79f9' aria-label='Anchor' data-anchorjs-icon='#'></a></span></h3>
<p class='with-space'>This collection is where the Smart Contract code and meta-data is stored. Contracts are deployed using an <strong>InvocationTransaction</strong> and saved under this prefix, where all code(script) and meta-data is stored. Note that the storage used by the contracts is put elsewhere (0x70 prefix), however, this is the collection used by a node to check if the contract, can use the storage or execute a dynamic invoke.</p>
<p class='with-space'>This collection is not deprecated yet, however, with plans of moving meta-data to a <code>Manifest</code> file, there is a chance this collection becomes depreciated in the near future.</p>
<p class='with-space'>In the check below, not only we check if the Smart Contract exists, but also if it can use the storage (deploying a contract that uses the storage is more expensive).</p>
<figure class='highlight'>
<button type='button' class='btn-clipboard' data-original-title='Copy to clipboard' data-clipboard-action='copy' data-toggle='tooltip' data-placement='top' title='Copy to clipboard' data-clipboard-text='internal bool CheckStorageContext(StorageContext context)
{
  ContractState contract = Snapshot.Contracts.TryGet(context.ScriptHash);
  if (contract == null) return false;
  if (!contract.HasStorage) return false;
    return true;
}'>Copy</button><pre><code class='csharp' lang='csharp'>internal bool CheckStorageContext(StorageContext context)
{
  ContractState contract = Snapshot.Contracts.TryGet(context.ScriptHash);
  if (contract == null) return false;
  if (!contract.HasStorage) return false;
    return true;
}
</code></pre>
</figure>
<p class='with-space'>Here is a verification done at runtime to ensure the contract has dynamic invoke flag:</p>
<figure class='highlight'>
<button type='button' class='btn-clipboard' data-original-title='Copy to clipboard' data-clipboard-action='copy' data-toggle='tooltip' data-placement='top' title='Copy to clipboard' data-clipboard-text='private bool CheckDynamicInvoke()
{
    Instruction instruction = CurrentContext.CurrentInstruction;
    switch (instruction.OpCode)
    {
        case OpCode.APPCALL:
        case OpCode.TAILCALL:
            if (instruction.Operand.NotZero()) return true;
            // if we get this far it is a dynamic call
            // now look at the current executing script
            // to determine if it can do dynamic calls
            return snapshot.Contracts[new UInt160(CurrentContext.ScriptHash)].HasDynamicInvoke;
        case OpCode.CALL_ED:
        case OpCode.CALL_EDT:
            return snapshot.Contracts[new UInt160(CurrentContext.ScriptHash)].HasDynamicInvoke;
        default:
            return true;
    }
}'>Copy</button><pre><code class='csharp' lang='csharp'>private bool CheckDynamicInvoke()
{
    Instruction instruction = CurrentContext.CurrentInstruction;
    switch (instruction.OpCode)
    {
        case OpCode.APPCALL:
        case OpCode.TAILCALL:
            if (instruction.Operand.NotZero()) return true;
            // if we get this far it is a dynamic call
            // now look at the current executing script
            // to determine if it can do dynamic calls
            return snapshot.Contracts[new UInt160(CurrentContext.ScriptHash)].HasDynamicInvoke;
        case OpCode.CALL_ED:
        case OpCode.CALL_EDT:
            return snapshot.Contracts[new UInt160(CurrentContext.ScriptHash)].HasDynamicInvoke;
        default:
            return true;
    }
}
</code></pre>
</figure>
<h3 id='b32f7899'><span class='with-space bd-content-title'>0x70 - Smart Contract Storage<a class='anchorjs-link ' href='#b32f7899' aria-label='Anchor' data-anchorjs-icon='#'></a></span></h3>
<p class='with-space'>This part of the storage is reserved for Smart Contract custom data storage. In this collection, we use the SmartContract script-hash as base prefix to all <code>Get</code> call executed by the ExecutionContext.</p>
<p class='with-space'>Here is an example of it&#39;s usage. Note that it also sends the context script-hash in order to retrieve the data:</p>
<figure class='highlight'>
<button type='button' class='btn-clipboard' data-original-title='Copy to clipboard' data-clipboard-action='copy' data-toggle='tooltip' data-placement='top' title='Copy to clipboard' data-clipboard-text='protected bool Storage_Get(ExecutionEngine engine)
{
   if (engine.CurrentContext.EvaluationStack.Pop() is InteropInterface _interface)
   {
       StorageContext context = _interface.GetInterface&lt;StorageContext&gt;();
       if (!CheckStorageContext(context)) return false;
       byte[] key = engine.CurrentContext.EvaluationStack.Pop().GetByteArray();
       StorageItem item = Snapshot.Storages.TryGet(new StorageKey
       {
           ScriptHash = context.ScriptHash,
           Key = key
       });
       engine.CurrentContext.EvaluationStack.Push(item?.Value ?? new byte[0]);
       return true;
   }
   return false;
}'>Copy</button><pre><code class='csharp' lang='csharp'>protected bool Storage_Get(ExecutionEngine engine)
{
   if (engine.CurrentContext.EvaluationStack.Pop() is InteropInterface _interface)
   {
       StorageContext context = _interface.GetInterface&lt;StorageContext&gt;();
       if (!CheckStorageContext(context)) return false;
       byte[] key = engine.CurrentContext.EvaluationStack.Pop().GetByteArray();
       StorageItem item = Snapshot.Storages.TryGet(new StorageKey
       {
           ScriptHash = context.ScriptHash,
           Key = key
       });
       engine.CurrentContext.EvaluationStack.Push(item?.Value ?? new byte[0]);
       return true;
   }
   return false;
}
</code></pre>
</figure>
<h3 id='a5527cb1'><span class='with-space bd-content-title'>0x80 - Header hash list<a class='anchorjs-link ' href='#a5527cb1' aria-label='Anchor' data-anchorjs-icon='#'></a></span></h3>
<p class='with-space'>NEO nodes sync block headers and block transactions separately, this means that first nodes download a list of headers (referenced by its hash), and pull the transactions list for each of this blocks separately, including getting this information from multiple nodes.
Note that the <code>Block</code> collections is also changed when we get new headers because a block is a header with transactions.</p>
<figure class='highlight'>
<button type='button' class='btn-clipboard' data-original-title='Copy to clipboard' data-clipboard-action='copy' data-toggle='tooltip' data-placement='top' title='Copy to clipboard' data-clipboard-text='private void OnNewHeaders(Header[] headers)
{
   using (Snapshot snapshot = GetSnapshot())
   {
       foreach (Header header in headers)
       {
           if (header.Index - 1 &gt;= header_index.Count) break;
           if (header.Index &lt; header_index.Count) continue;
           if (!header.Verify(snapshot)) break;
           header_index.Add(header.Hash);
           snapshot.Blocks.Add(header.Hash, new BlockState
           {
               SystemFeeAmount = 0,
               TrimmedBlock = header.Trim()
           });
           snapshot.HeaderHashIndex.GetAndChange().Hash = header.Hash;
           snapshot.HeaderHashIndex.GetAndChange().Index = header.Index;
       }
       SaveHeaderHashList(snapshot);
       snapshot.Commit();
   }
   UpdateCurrentSnapshot();
   system.TaskManager.Tell(new TaskManager.HeaderTaskCompleted(), Sender);
}'>Copy</button><pre><code class='csharp' lang='csharp'>private void OnNewHeaders(Header[] headers)
{
   using (Snapshot snapshot = GetSnapshot())
   {
       foreach (Header header in headers)
       {
           if (header.Index - 1 &gt;= header_index.Count) break;
           if (header.Index &lt; header_index.Count) continue;
           if (!header.Verify(snapshot)) break;
           header_index.Add(header.Hash);
           snapshot.Blocks.Add(header.Hash, new BlockState
           {
               SystemFeeAmount = 0,
               TrimmedBlock = header.Trim()
           });
           snapshot.HeaderHashIndex.GetAndChange().Hash = header.Hash;
           snapshot.HeaderHashIndex.GetAndChange().Index = header.Index;
       }
       SaveHeaderHashList(snapshot);
       snapshot.Commit();
   }
   UpdateCurrentSnapshot();
   system.TaskManager.Tell(new TaskManager.HeaderTaskCompleted(), Sender);
}
</code></pre>
</figure>
<h3 id='f99df5e7'><span class='with-space bd-content-title'>0x90 - Validators count<a class='anchorjs-link ' href='#f99df5e7' aria-label='Anchor' data-anchorjs-icon='#'></a></span></h3>
<h3 id='b9856d25'><span class='with-space bd-content-title'>0xc0 - Current block<a class='anchorjs-link ' href='#b9856d25' aria-label='Anchor' data-anchorjs-icon='#'></a></span></h3>
<p class='with-space'>The current block represents the highest block verified block, with it&#39;s transactions. We store it this information to know the latest (higher) synchronized block. The current blockchain height is defined by the height of the object in this key.</p>
<figure class='highlight'>
<button type='button' class='btn-clipboard' data-original-title='Copy to clipboard' data-clipboard-action='copy' data-toggle='tooltip' data-placement='top' title='Copy to clipboard' data-clipboard-text='public uint Height =&gt; BlockHashIndex.Get().Index;'>Copy</button><pre><code class='csharp' lang='csharp'>public uint Height =&gt; BlockHashIndex.Get().Index;
</code></pre>
</figure>
<p class='with-space'>Remember: A block <strong>is</strong> a block-header with additional information (transactions), so the block hash is always the same as it&#39;s block-header hash.</p>
<h3 id='f54a3d13'><span class='with-space bd-content-title'>0xc1 - Current header<a class='anchorjs-link ' href='#f54a3d13' aria-label='Anchor' data-anchorjs-icon='#'></a></span></h3>
<p class='with-space'>This prefix is used to store the latest(higher) block header. This is considered meta-data and is used only to help the node to synchronize it&#39;s data.</p>
<figure class='highlight'>
<button type='button' class='btn-clipboard' data-original-title='Copy to clipboard' data-clipboard-action='copy' data-toggle='tooltip' data-placement='top' title='Copy to clipboard' data-clipboard-text='public override MetaDataCache&lt;HashIndexState&gt; GetHeaderHashIndex()
{
  return new DbMetaDataCache&lt;HashIndexState&gt;(db, null, null, Prefixes.IX_CurrentHeader);
}

public Blockchain(NeoSystem system, Store store)
{
 this.system = system;
 this.MemPool = new MemoryPool(system, MemoryPoolMaxTransactions);
 this.Store = store;
 lock (lockObj)
 {
     if (singleton != null)
         throw new InvalidOperationException();
     header_index.AddRange(store.GetHeaderHashList().Find().OrderBy(p =&gt; (uint)p.Key).SelectMany(p =&gt; p.Value.Hashes));
     stored_header_count += (uint)header_index.Count;
     if (stored_header_count == 0)
     {
         header_index.AddRange(store.GetBlocks().Find().OrderBy(p =&gt; p.Value.TrimmedBlock.Index).Select(p =&gt; p.Key));
     }
     else
     {
         HashIndexState hashIndex = store.GetHeaderHashIndex().Get();
         if (hashIndex.Index &gt;= stored_header_count)
         {
           DataCache&lt;UInt256, BlockState&gt; cache = store.GetBlocks();
           for (UInt256 hash = hashIndex.Hash; hash != header_index[(int)stored_header_count - 1];)
           {
             header_index.Insert((int)stored_header_count, hash);
             hash = cache[hash].TrimmedBlock.PrevHash;
           }
         }
     }
     if (header_index.Count == 0)
         Persist(GenesisBlock);
     else
         UpdateCurrentSnapshot();
         singleton = this;
   }
}'>Copy</button><pre><code class='csharp' lang='csharp'>public override MetaDataCache&lt;HashIndexState&gt; GetHeaderHashIndex()
{
  return new DbMetaDataCache&lt;HashIndexState&gt;(db, null, null, Prefixes.IX_CurrentHeader);
}

public Blockchain(NeoSystem system, Store store)
{
 this.system = system;
 this.MemPool = new MemoryPool(system, MemoryPoolMaxTransactions);
 this.Store = store;
 lock (lockObj)
 {
     if (singleton != null)
         throw new InvalidOperationException();
     header_index.AddRange(store.GetHeaderHashList().Find().OrderBy(p =&gt; (uint)p.Key).SelectMany(p =&gt; p.Value.Hashes));
     stored_header_count += (uint)header_index.Count;
     if (stored_header_count == 0)
     {
         header_index.AddRange(store.GetBlocks().Find().OrderBy(p =&gt; p.Value.TrimmedBlock.Index).Select(p =&gt; p.Key));
     }
     else
     {
         HashIndexState hashIndex = store.GetHeaderHashIndex().Get();
         if (hashIndex.Index &gt;= stored_header_count)
         {
           DataCache&lt;UInt256, BlockState&gt; cache = store.GetBlocks();
           for (UInt256 hash = hashIndex.Hash; hash != header_index[(int)stored_header_count - 1];)
           {
             header_index.Insert((int)stored_header_count, hash);
             hash = cache[hash].TrimmedBlock.PrevHash;
           }
         }
     }
     if (header_index.Count == 0)
         Persist(GenesisBlock);
     else
         UpdateCurrentSnapshot();
         singleton = this;
   }
}
</code></pre>
</figure>
<h3 id='ca63dbb6'><span class='with-space bd-content-title'>0xf0 - System version<a class='anchorjs-link ' href='#ca63dbb6' aria-label='Anchor' data-anchorjs-icon='#'></a></span></h3>
<p class='with-space'>The <code>SYS_Version</code> prefix is used to track the current system version. This check is used to ensure that the data we are using is compatible with our system.</p>
<p class='with-space'>We can see it&#39;s usage in node code <a href='https://github.com/neo-project/neo/blob/master/neo/Persistence/LevelDB/LevelDBStore.cs' target='_blank'> here</a> and also at wallet level [here]()</p>
<p class='with-space'>Node usage:</p>
<figure class='highlight'>
<button type='button' class='btn-clipboard' data-original-title='Copy to clipboard' data-clipboard-action='copy' data-toggle='tooltip' data-placement='top' title='Copy to clipboard' data-clipboard-text='public LevelDBStore(string path)
{
  this.db = DB.Open(path, new Options { CreateIfMissing = true });
  if (db.TryGet(ReadOptions.Default, SliceBuilder.Begin(Prefixes.SYS_Version), out Slice value) &amp;&amp; Version.TryParse(value.ToString(), out Version version) &amp;&amp; version &gt;= Version.Parse(&quot;2.9.1&quot;))
    return;
  WriteBatch batch = new WriteBatch();
  ReadOptions options = new ReadOptions { FillCache = false };
  using (Iterator it = db.NewIterator(options))
  {
    for (it.SeekToFirst(); it.Valid(); it.Next())
    {
      batch.Delete(it.Key());
    }
  }
  db.Put(WriteOptions.Default, SliceBuilder.Begin(Prefixes.SYS_Version), Assembly.GetExecutingAssembly().GetName().Version.ToString());
  db.Write(WriteOptions.Default, batch);
}'>Copy</button><pre><code class='csharp' lang='csharp'>public LevelDBStore(string path)
{
  this.db = DB.Open(path, new Options { CreateIfMissing = true });
  if (db.TryGet(ReadOptions.Default, SliceBuilder.Begin(Prefixes.SYS_Version), out Slice value) &amp;&amp; Version.TryParse(value.ToString(), out Version version) &amp;&amp; version &gt;= Version.Parse(&quot;2.9.1&quot;))
    return;
  WriteBatch batch = new WriteBatch();
  ReadOptions options = new ReadOptions { FillCache = false };
  using (Iterator it = db.NewIterator(options))
  {
    for (it.SeekToFirst(); it.Valid(); it.Next())
    {
      batch.Delete(it.Key());
    }
  }
  db.Put(WriteOptions.Default, SliceBuilder.Begin(Prefixes.SYS_Version), Assembly.GetExecutingAssembly().GetName().Version.ToString());
  db.Write(WriteOptions.Default, batch);
}
</code></pre>
</figure>
<p class='with-space'>Wallet usage:</p>
<figure class='highlight'>
<button type='button' class='btn-clipboard' data-original-title='Copy to clipboard' data-clipboard-action='copy' data-toggle='tooltip' data-placement='top' title='Copy to clipboard' data-clipboard-text='public WalletIndexer(string path)
{
  path = Path.GetFullPath(path);
  Directory.CreateDirectory(path);
  db = DB.Open(path, new Options { CreateIfMissing = true });
  if (db.TryGet(ReadOptions.Default, SliceBuilder.Begin(DataEntryPrefix.SYS_Version), out Slice value) &amp;&amp; Version.TryParse(value.ToString(), out Version version) &amp;&amp; version &gt;= Version.Parse(&quot;2.5.4&quot;))
  {
      ReadOptions options = new ReadOptions { FillCache = false };
      foreach (var group in db.Find(options, SliceBuilder.Begin(DataEntryPrefix.IX_Group), (k, v) =&gt; new
      {
          Height = k.ToUInt32(1),
          Id = v.ToArray()
      }))
      {
          UInt160[] accounts = db.Get(options, SliceBuilder.Begin(DataEntryPrefix.IX_Accounts).Add(group.Id)).ToArray().AsSerializableArray&lt;UInt160&gt;();
          indexes.Add(group.Height, new HashSet&lt;UInt160&gt;(accounts));
          foreach (UInt160 account in accounts)
              accounts_tracked.Add(account, new HashSet&lt;CoinReference&gt;());
      }
      foreach (Coin coin in db.Find(options, SliceBuilder.Begin(DataEntryPrefix.ST_Coin), (k, v) =&gt; new Coin
      {
          Reference = k.ToArray().Skip(1).ToArray().AsSerializable&lt;CoinReference&gt;(),
          Output = v.ToArray().AsSerializable&lt;TransactionOutput&gt;(),
          State = (CoinState)v.ToArray()[60]
      }))
      {
          accounts_tracked[coin.Output.ScriptHash].Add(coin.Reference);
          coins_tracked.Add(coin.Reference, coin);
      }
  }
  else
  {
      WriteBatch batch = new WriteBatch();
      ReadOptions options = new ReadOptions { FillCache = false };
      using (Iterator it = db.NewIterator(options))
      {
          for (it.SeekToFirst(); it.Valid(); it.Next())
          {
              batch.Delete(it.Key());
          }
      }
      batch.Put(SliceBuilder.Begin(DataEntryPrefix.SYS_Version), Assembly.GetExecutingAssembly().GetName().Version.ToString());
      db.Write(WriteOptions.Default, batch);
  }
  thread = new Thread(ProcessBlocks)
  {
      IsBackground = true,
      Name = $&quot;{nameof(WalletIndexer)}.{nameof(ProcessBlocks)}&quot;
  };
thread.Start();
}'>Copy</button><pre><code class='csharp' lang='csharp'>public WalletIndexer(string path)
{
  path = Path.GetFullPath(path);
  Directory.CreateDirectory(path);
  db = DB.Open(path, new Options { CreateIfMissing = true });
  if (db.TryGet(ReadOptions.Default, SliceBuilder.Begin(DataEntryPrefix.SYS_Version), out Slice value) &amp;&amp; Version.TryParse(value.ToString(), out Version version) &amp;&amp; version &gt;= Version.Parse(&quot;2.5.4&quot;))
  {
      ReadOptions options = new ReadOptions { FillCache = false };
      foreach (var group in db.Find(options, SliceBuilder.Begin(DataEntryPrefix.IX_Group), (k, v) =&gt; new
      {
          Height = k.ToUInt32(1),
          Id = v.ToArray()
      }))
      {
          UInt160[] accounts = db.Get(options, SliceBuilder.Begin(DataEntryPrefix.IX_Accounts).Add(group.Id)).ToArray().AsSerializableArray&lt;UInt160&gt;();
          indexes.Add(group.Height, new HashSet&lt;UInt160&gt;(accounts));
          foreach (UInt160 account in accounts)
              accounts_tracked.Add(account, new HashSet&lt;CoinReference&gt;());
      }
      foreach (Coin coin in db.Find(options, SliceBuilder.Begin(DataEntryPrefix.ST_Coin), (k, v) =&gt; new Coin
      {
          Reference = k.ToArray().Skip(1).ToArray().AsSerializable&lt;CoinReference&gt;(),
          Output = v.ToArray().AsSerializable&lt;TransactionOutput&gt;(),
          State = (CoinState)v.ToArray()[60]
      }))
      {
          accounts_tracked[coin.Output.ScriptHash].Add(coin.Reference);
          coins_tracked.Add(coin.Reference, coin);
      }
  }
  else
  {
      WriteBatch batch = new WriteBatch();
      ReadOptions options = new ReadOptions { FillCache = false };
      using (Iterator it = db.NewIterator(options))
      {
          for (it.SeekToFirst(); it.Valid(); it.Next())
          {
              batch.Delete(it.Key());
          }
      }
      batch.Put(SliceBuilder.Begin(DataEntryPrefix.SYS_Version), Assembly.GetExecutingAssembly().GetName().Version.ToString());
      db.Write(WriteOptions.Default, batch);
  }
  thread = new Thread(ProcessBlocks)
  {
      IsBackground = true,
      Name = $&quot;{nameof(WalletIndexer)}.{nameof(ProcessBlocks)}&quot;
  };
thread.Start();
}
</code></pre>
</figure>
<h2 id='d9a58ba2'><span class='with-space bd-content-title'>What&#39;s next?<a class='anchorjs-link ' href='#d9a58ba2' aria-label='Anchor' data-anchorjs-icon='#'></a></span></h2>
<p class='with-space'> <a href='../7-consensus/1-Introduction_to_consensus.html'> Introduction to Consensus</a> </p>
            </main>
            <div class="d-none d-lg-block side-nav py-2 py-md-5">
                <a href="https://github.com/neo-project/docs/blob/master/tutorial/en-us/6-persistence\2-levelDB_data_structure.md" class="contribution-link d-block">Improve this Doc</a>
                <div class="side-nav-text">In this article</div>
                <div id="navbar-sidenav">
                    <nav class='nav nav-pills flex-column'>
<a class='ml--2 d-none my-1 nav-link' href='#d5d1991e'>LevelDB Blockchain Data Structure</a>
<nav class='nav nav-pills flex-column'>
<a class='ml-0 my-1 nav-link' href='#d8ea9052'>LevelDB Table Structure</a>
<nav class='nav nav-pills flex-column'>
<a class='ml-2 my-1 nav-link' href='#f1722025'>Memory Pool</a>
<a class='ml-2 my-1 nav-link' href='#fad32880'>0x01 - Blocks</a>
<a class='ml-2 my-1 nav-link' href='#df1547df'>0x02 - Transactions</a>
<a class='ml-2 my-1 nav-link' href='#e5652612'>0x40 - Accounts</a>
<a class='ml-2 my-1 nav-link' href='#e923aea4'>0x44 - (Unspent) Coins collections</a>
<a class='ml-2 my-1 nav-link' href='#abae2fef'>0x45 - Spent Coins</a>
<a class='ml-2 my-1 nav-link' href='#a1c40fdc'>0x48 - Validators</a>
<a class='ml-2 my-1 nav-link' href='#e6097367'>0x4c - (Native) Assets</a>
<a class='ml-2 my-1 nav-link' href='#fc8a79f9'>0x50 - Contract</a>
<a class='ml-2 my-1 nav-link' href='#b32f7899'>0x70 - Smart Contract Storage</a>
<a class='ml-2 my-1 nav-link' href='#a5527cb1'>0x80 - Header hash list</a>
<a class='ml-2 my-1 nav-link' href='#f99df5e7'>0x90 - Validators count</a>
<a class='ml-2 my-1 nav-link' href='#b9856d25'>0xc0 - Current block</a>
<a class='ml-2 my-1 nav-link' href='#f54a3d13'>0xc1 - Current header</a>
<a class='ml-2 my-1 nav-link' href='#ca63dbb6'>0xf0 - System version</a>
</nav>
<a class='ml-0 my-1 nav-link' href='#d9a58ba2'>What's next?</a>
</nav>
</nav>
                </div>
            </div>
        </div>
    </div>
    <div class="lightbulb" title="Turn On/Off" onclick="turnOff()">
        <i class="far fa-lightbulb"></i>
    </div>
    <footer>
        <div class="d-flex justify-content-between py-1 px-3 px-sm-4 px-md-5">
            <ul class="d-none d-md-block">
                <li><a href="https://github.com/neo-project/docs" title="GitHub" target="_blank">GitHub</a></li>
                <li><a href="https://github.com/neo-project/docs/issues" title="Issue" target="_blank">Issue</a></li>
                <li><a href="https://discord.io/neo" title="Discord" target="_blank">Discord</a></li>
            </ul>
            <p>Build by <a href="https://github.com/chenzhitong/NeoDocsBuilder" title="NeoDocsBuilder" target="_blank">NeoDocsBuilder</a></p>
            <p>Licensed under <a href="https://github.com/neo-project/docs/blob/master/LICENSE" title="CC-BY-4.0" target="_blank">CC-BY-4.0</a> license. </p>
        </div>
    </footer>
    <script src="https://neo-cdn.azureedge.net/lib/jquery/jquery.min.js"></script>
    <script src="https://neo-cdn.azureedge.net/lib/popper.js/popper.min.js"></script>
    <script src="https://neo-cdn.azureedge.net/lib/bootstrap/js/bootstrap.min.js"></script>
    <script src="https://neo-cdn.azureedge.net/js/jquery.lazyload.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.8/highlight.min.js"></script>
    <script src="https://neo-cdn.azureedge.net/js/text-autospace.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js"></script>
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-130525731-2"></script>
    <script src="/js/site.min.js"></script>
    <script>
        //适用于FAQ的根据标题展开收缩
        if (false) {
            $("h2").click(function (e) {
                $(".div-collapse").not($(e.target).parents("h2").next()).hide("fast");
                $(e.target).parents("h2").next().toggle("fast");
            });
        }
    </script>
</body>
</html>

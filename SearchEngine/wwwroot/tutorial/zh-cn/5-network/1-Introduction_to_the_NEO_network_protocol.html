<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="format-detection" content="telephone=no" />
    <meta name="robots" content="index,follow">
    <meta name="author" content="neo-project">
    <meta name="application-name" content="neo.org">
    <meta name="renderer" content="ie-stand">
    <title>NEO 协议和网络</title>
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Neo Documentation" />
    <meta property="og:description" content="Neo Documentation" />
    <meta property="og:image" content="/img/twitter-img.jpg" />
    <meta name="twitter:title" content="Neo Documentation" />
    <meta name="twitter:description" content="Neo Documentation" />
    <meta name="twitter:image" content="/img/twitter-img.jpg" />
    <meta name="twitter:card" content="summary_large_image" />

    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/img/favicon-16x16.png">
    <link rel="manifest" href="/img/site.webmanifest">
    <link rel="mask-icon" href="/img/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#00aba9">
    <meta name="theme-color" content="#ffffff">

    <link href="https://neo-cdn.azureedge.net/lib/bootstrap/css/bootstrap.min.css" rel="stylesheet" />
    <link href="https://neo-cdn.azureedge.net/lib/animate.css/animate.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.8/styles/default.min.css">
    <link href="/lib/font-awesome/css/all.min.css" rel="stylesheet" />
    <link href="/css/site.min.css" rel="stylesheet" />
</head>
<body data-spy="scroll" data-target="#navbar-sidenav">
    <nav class="navbar fixed-top navbar-expand-lg py-1 px-3 px-sm-4 px-md-5">
        <a class="navbar-brand" href="https://neo.org">
            <img class="logo" src="/img/logo.svg" alt="NEO Logo" />
            <img class="logo-dark" src="/img/logo-dark.svg" alt="NEO Logo" />
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <i class="fas fa-bars"></i>
        </button>
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav ml-auto">
                <li class="nav-item">
                    <a class="nav-link" href="/docs">Documentation</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="/tutorial">Tutorial</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="/faq">FAQ</a>
                </li>
                <li class="nav-item" style="margin-right: 100px">
                    <a class="nav-link" href="/articles">Articles</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link d-inline-block" href="javascript:" onclick="language('en-us')">EN</a>|<a class="nav-link d-inline-block" href="javascript:" onclick="language('zh-cn')">中文</a>
                </li>
            </ul>
            <form class="form-inline my-2 my-lg-0 d-none">
                <input class="form-control mr-sm-2" type="search" placeholder="Search" aria-label="Search">
                <button class="btn btn-outline-success my-2 my-sm-0" type="submit">Search</button>
            </form>
        </div>
    </nav>
    <div class="container-fluid" style="margin-top: 55px">
        <div class="row d-flex">
            <div class="d-none d-md-block catalog py-2 py-md-5 pl-md-3">
                
<nav class='nav nav-pills flex-column ml-3'>
<span class='ml-0 my-1 nav-link'><i class='fas fa-caret-right'></i>NEO 介绍</span>
<nav class='nav nav-pills flex-column ml-3'>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/1-introduction/1-Introduction_to_NEO.html'>简介</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/1-introduction/2-Cryptography_Blockchain_and_Smart_Contracts.html'>密码学、区块链和智能合约</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/1-introduction/3-Fundamentals_of_NEO.html'>基础知识</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/1-introduction/resource.html'>更多资源</a>
</nav>
<span class='ml-0 my-1 nav-link'><i class='fas fa-caret-right'></i>钱包</span>
<nav class='nav nav-pills flex-column ml-3'>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/2-wallet/1-Introduction_to_wallets.html'>介绍</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/2-wallet/2-Key_derivation_and_address_generation_on_NEO.html'>私钥和地址生成</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/2-wallet/3-Key_encryption_and_contract_accounts.html'>私钥与合约账户</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/2-wallet/4-UTXO_and_account_models.html'>UTXO 与账户模型</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/2-wallet/resource.html'>更多资源</a>
</nav>
<span class='ml-0 my-1 nav-link'><i class='fas fa-caret-right'></i>交易</span>
<nav class='nav nav-pills flex-column ml-3'>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/3-transactions/1-Introduction_to_transactions.html'>介绍</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/3-transactions/2-Structure_of_NEO_transactions.html'>交易结构</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/3-transactions/3-NEO_transaction_types.html'>交易类型</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/3-transactions/4-NEO_transaction_fees.html'>交易手续费</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/3-transactions/resource.html'>更多资源</a>
</nav>
<span class='ml-0 my-1 nav-link'><i class='fas fa-caret-right'></i>区块</span>
<nav class='nav nav-pills flex-column ml-3'>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/4-blocks/1-Introduction_to_blocks_and_blockchain.html'>介绍</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/4-blocks/2-Structure_of_a_block.html'>区块结构</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/4-blocks/3-Block_creation_broadcasting.html'>区块创建与广播</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/4-blocks/4-Block_validation_processing.html'>区块验证</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/4-blocks/resource.html'>更多资源</a>
</nav>
<span class='ml-0 my-1 nav-link'><i class='fas fa-caret-right'></i>NEO 网络</span>
<nav class='nav nav-pills flex-column ml-3'>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/5-network/1-Introduction_to_the_NEO_network_protocol.html'>协议和网络</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/5-network/resource.html'>更多资源</a>
</nav>
<span class='ml-0 my-1 nav-link'><i class='fas fa-caret-right'></i>持久性</span>
<nav class='nav nav-pills flex-column ml-3'>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/6-persistence/1-persistence.html'>介绍</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/6-persistence/2-levelDB_data_structure.html'>LevelDB 数据结构</a>
</nav>
<span class='ml-0 my-1 nav-link'><i class='fas fa-caret-right'></i>共识机制</span>
<nav class='nav nav-pills flex-column ml-3'>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/7-consensus/1-Introduction_to_consensus.html'>介绍</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/7-consensus/2-Proof_of_work_and_proof_of_stake.html'>PoW 与 PoS</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/7-consensus/3-PBFT_and_DBFT.html'>pBFT 与 dBFT</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/7-consensus/4-Examples_and_consensus_scenarios_for_dBFT.html'>共识示例与场景</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/7-consensus/resource.html'>更多资源</a>
</nav>
<span class='ml-0 my-1 nav-link'><i class='fas fa-caret-right'></i>智能合约</span>
<nav class='nav nav-pills flex-column ml-3'>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/9-smartContract/What_is_smart_contract.html'>介绍</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/9-smartContract/Development_privateChain.html'>搭建私链</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/9-smartContract/Development_set_up.html'>搭建开发环境</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/9-smartContract/Development_compile.html'>编译、调用与部署</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/9-smartContract/Smart_Contract_basics.html'>智能合约基础</a>
<span class='ml-0 my-1 nav-link'><i class='fas fa-caret-right'></i>创建 NEP-5 合约</span>
<nav class='nav nav-pills flex-column ml-3'>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/9-smartContract/What_is_nep5.html'>介绍</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/9-smartContract/Implementation_of_NEP5.html'>实现 NEP-5</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/9-smartContract/Give_an_ITO.html'>ITO</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/9-smartContract/UTXO.html'>UTXO 基础</a>
</nav>
<span class='ml-0 my-1 nav-link'><i class='fas fa-caret-right'></i>CGAS</span>
<nav class='nav nav-pills flex-column ml-3'>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/9-smartContract/cgas/1_what_is_cgas.html'>什么是 CGAS</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/9-smartContract/cgas/2_global_asset_and_nep5.html'>全局资产与 NEP-5</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/9-smartContract/cgas/3_utxo_model.html'>UTXO 模型</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/9-smartContract/cgas/4_trigger.html'>触发器</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/9-smartContract/cgas/5_minttokens_and_refund.html'>铸币与退款</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/9-smartContract/cgas/6_signature_and_verification.html'>签名与验证</a>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/9-smartContract/cgas/7_invocation.html'>交易调用</a>
</nav>
<a class='ml-0 my-1 nav-link' href='/tutorial/zh-cn/9-smartContract/neo_python_quickstart_cn.html'>NEO Python 快速入门</a>
</nav>
</nav>
            </div>
            <main class="p-3 p-sm-4 p-md-5">
                <a class="d-block d-md-none" href="javascript:" onclick="showCatalog()">Show / Hide Table of Contents</a>
                <h1 id='ed93e18f'><span class='with-space bd-content-title'>NEO 协议和网络<a class='anchorjs-link ' href='#ed93e18f' aria-label='Anchor' data-anchorjs-icon='#'></a></span></h1>
<p class='with-space'>NEO网络由两种协议组成：与本地客户端和钱包进行通信的协议，以及与NEO网络中其他节点通信的外部协议。与本地节点进行连接使用的是 <a href='https://www.jsonrpc.org/' target='_blank'> JSON-RPC</a> 协议。也可以通过JSON-RPC连接到外部节点。</p>
<figure class='highlight'>
<button type='button' class='btn-clipboard' data-original-title='Copy to clipboard' data-clipboard-action='copy' data-toggle='tooltip' data-placement='top' title='Copy to clipboard' data-clipboard-text='                          +--------------+
+----------+              | +----------+ |
|          | NEO 协议| |          | |
| NEO 节点+----------------+ NEO 对等节点| |
|          |              | |          | |
+----------+              | +----+-----+ |
                          |      |       |
                          |      |JSON   |
                          |      |RPC    |
                          |      |       |
                          | +----+-----+ |
                          | |          | |
                          | |本地节点| |
                          | |          | |
                          | +----------+ |
                          +--------------+
                              NEO 节点'>Copy</button><pre><code>                          +--------------+
+----------+              | +----------+ |
|          | NEO 协议| |          | |
| NEO 节点+----------------+ NEO 对等节点| |
|          |              | |          | |
+----------+              | +----+-----+ |
                          |      |       |
                          |      |JSON   |
                          |      |RPC    |
                          |      |       |
                          | +----+-----+ |
                          | |          | |
                          | |本地节点| |
                          | |          | |
                          | +----------+ |
                          +--------------+
                              NEO 节点
</code></pre>
</figure>
<p class='with-space'>在本教程中，我们将重点介绍另一个协议， <a href='https://docs.neo.org/docs/zh-cn/tooldev/advanced/network-protocol.html' target='_blank'> NEO协议</a> 。我们将使用Golang语言来学习如何与NEO节点通信。</p>
<h2 id='a3cedf5f'><span class='with-space bd-content-title'>使用Golang来Ping NEO 网络<a class='anchorjs-link ' href='#a3cedf5f' aria-label='Anchor' data-anchorjs-icon='#'></a></span></h2>
<p class='with-space'>虽然很多的 <a href='https://github.com/neo-project/neo' target='_blank'> NEO核心库</a> 都是用C#或Python编写的，但在本教程中，我们将使用 <a href='https://golang.org/' target='_blank'> Golang</a> 语言。通信基础对任何语言而言都是相同的。</p>
<p class='with-space'>NEO协议定义了一个区块头和一个payload。每个报文都需要按照特定的格式发送，即24字节长的协议头以及相应的payload：</p>
<figure class='highlight'>
<button type='button' class='btn-clipboard' data-original-title='Copy to clipboard' data-clipboard-action='copy' data-toggle='tooltip' data-placement='top' title='Copy to clipboard' data-clipboard-text=' 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      魔法数: 0x00746E41                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                                                               +
|                      命令: 12 字节                            |
+                                                               +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-++-+-++-+-++-+-++-+-+-+-+-+-+-+-+
|                        Payload 长度                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-++-+-++-+-++-+-++-+-+-+-+-+-+-+-+
|                       Payload 校验和                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-++-+-++-+-++-+-++-+-+-+-+-+-+-+-+
|                                                               |
|                           Payload                             |'>Copy</button><pre><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      魔法数: 0x00746E41                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                                                               +
|                      命令: 12 字节                            |
+                                                               +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-++-+-++-+-++-+-++-+-+-+-+-+-+-+-+
|                        Payload 长度                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-++-+-++-+-++-+-++-+-+-+-+-+-+-+-+
|                       Payload 校验和                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-++-+-++-+-++-+-++-+-+-+-+-+-+-+-+
|                                                               |
|                           Payload                             |
</code></pre>
</figure>
<p class='with-space'>与其他NEO节点的通信是通过TCP或 <a href='https://developer.mozilla.org/en-us/docs/web/api/websockets_-api' target='_blank'> WebSockets</a> 进行的。使用WebSockets的好处是，你可以通过Web浏览器连接到NEO节点。不过在本教程中，我们使用的是TCP协议。</p>
<p class='with-space'>协议头包含一个4字节的魔法数，代表的是“Ant”（小端存储），这个名称是在NEO品牌重塑之前使用的。测试网使用的魔法数有些许不同，从而来区分主网和测试网的消息。</p>
<hr />
<p class='with-space'> <strong>练习1</strong> : 请回答以下问题：</p>
<p class='with-space'>尽管兼容性非常重要，而更改协议的格式可能会对客户端的运行产生影响，不过理论上来说，可以对协议头做哪些优化呢？</p>
<hr />
<p class='with-space'>为了加入到NEO分布式系统，首先，我们需要先建立一个到NEO节点的连接。由于我们会用到ping/pong命令，这个命令在2019年4月4日发布的NEO v2.10.1版本中已经实现了，所以我们需要确保我们的节点运行了这个版本。可以点击此处 <a href='http://monitor.cityofzion.io/' target='_blank'> http://monitor.cityofzion.io/</a> 查看运行了该版本的NEO节点列表。在编写本文档的时候，以下几个节点使用了该版本：</p>
<ul class='with-space'>
<li>
<p class='with-space'>node1.plutolo.gy:10333</p></li>
<li>
<p class='with-space'>seed.neoeconomy.io:10333</p></li>
<li>
<p class='with-space'>seed10.ngd.network:10333</p></li>
</ul>
<p class='with-space'>请注意，节点可能会随时下线，上面这几个节点也可能不会再上线了。可以替换为运行了v2.10.1以上版本的任意的NEO节点。</p>
<p class='with-space'>这些节点必须能够在相应的端口上提供很好的可访问性。主网的默认端口是10333。如果节点开启了防火墙，可以使用UPnP配置路由从而接受发送到节点的传入连接请求。目前不支持NAT-PMP。在本教程中，我们不会接受任何的传入连接，这意味着不会有任何NAT问题。</p>
<p class='with-space'>让我们来实现这个协议。我们需要做的是：首先设置魔法数，然后设置紧跟着payload长度的命令。之后计算校验和并附加payload信息。现在，我们可以将报文发送到一个NEO节点。听起来很简单，对吧？</p>
<h3 id='dccff549'><span class='with-space bd-content-title'>小端和大端<a class='anchorjs-link ' href='#dccff549' aria-label='Anchor' data-anchorjs-icon='#'></a></span></h3>
<p class='with-space'>对于每个协议，都必须定义使用的是哪种字节顺序。NEO中使用的是小端存储。因此，魔法数字节的编码如下所示： <code>` 0x00746E41 -&gt; [41][6E][74][00]</code> ` 大端编码看起来是这样的： <a href='javascript:'> 00</a>  <a href='javascript:'> 6E</a> 。许多编程语言都提供了相应的转换工具，Golang中的操作是这样的：</p>
<figure class='highlight'>
<button type='button' class='btn-clipboard' data-original-title='Copy to clipboard' data-clipboard-action='copy' data-toggle='tooltip' data-placement='top' title='Copy to clipboard' data-clipboard-text='binary.LittleEndian.PutUint32(b[0:], 0x00746E41)'>Copy</button><pre><code>binary.LittleEndian.PutUint32(b[0:], 0x00746E41)
</code></pre>
</figure>
<p class='with-space'>虽然大多数CPU使用的是小端编码，但是网络协议（如TCP或UDP）使用的是大端序。有关端序的更多信息，请查看 <a href='https://en.wikipedia.org/wiki/endianness' target='_blank'> https://en.wikipedia.org/wiki/endianness</a> 。在本教程中，我们使用的是小端序，因为NEO中的大部分数据都是使用小端编码的，并且我们不会涉及到异常问题。</p>
<h3 id='f625f1fe'><span class='with-space bd-content-title'>校验和<a class='anchorjs-link ' href='#f625f1fe' aria-label='Anchor' data-anchorjs-icon='#'></a></span></h3>
<p class='with-space'>协议头中的校验和字段是针对payload计算出的校验和。虽然TCP在其payload上也有校验和，但TCP的校验和只有16位。NEO中的payload校验和是对payload进行两次SHA256哈希之后取最终结果的前4字节（32位）。在Golang中，校验和的计算方法如下所示：</p>
<figure class='highlight'>
<button type='button' class='btn-clipboard' data-original-title='Copy to clipboard' data-clipboard-action='copy' data-toggle='tooltip' data-placement='top' title='Copy to clipboard' data-clipboard-text=' tmp := sha256.Sum256(payload)
 hash := sha256.Sum256(tmp[:])
 ...
 copy(b[20:], hash[0:4])'>Copy</button><pre><code> tmp := sha256.Sum256(payload)
 hash := sha256.Sum256(tmp[:])
 ...
 copy(b[20:], hash[0:4])
</code></pre>
</figure>
<p class='with-space'>如果校验和不匹配，节点应该忽略这条消息。</p>
<hr />
<p class='with-space'> <strong>练习2</strong> : 编写用于协议头的编码器和解码器。使用底下附录A中 “快速而粗糙”的模板，实现以下两个功能： <code>encodeheader（cmd string，payload[]byte）[]byte</code> ，其中返回的数组是组合了payload的协议头。编码器应该返回可以发送到链路的完整的字节数组。另一个是 <code>decodeheader（b[]byte）（uint32，uint32）</code> ，其中第一个返回值是payload的长度，第二个值是校验和。</p>
<hr />
<h3 id='d0048a33'><span class='with-space bd-content-title'>Payload协议<a class='anchorjs-link ' href='#d0048a33' aria-label='Anchor' data-anchorjs-icon='#'></a></span></h3>
<p class='with-space'>实现了NEO协议头的编码和解码功能之后，我们可以专注于payload了。NEO协议支持以下这些命令，不过并不是所有命令都具有payload。</p>
<ul class='with-space'>
<li>
<p class='with-space'>version - 节点版本的相关信息，包括版本号</p></li>
<li>
<p class='with-space'>verack - 成功接收到版本信息时，发送应答信息verack（无payload）</p></li>
<li>
<p class='with-space'>getaddr - 请求活跃的NEO节点列表</p></li>
<li>
<p class='with-space'>addr - 对getaddr请求的响应</p></li>
<li>
<p class='with-space'>getBlocks - 请求区块</p></li>
<li>
<p class='with-space'>block - 对getblocks或getdata的响应</p></li>
<li>
<p class='with-space'>consensus - 对getdata的响应</p></li>
<li>
<p class='with-space'>filteradd - 向布隆过滤器添加数据</p></li>
<li>
<p class='with-space'>filterclear - 清除布隆过滤器</p></li>
<li>
<p class='with-space'>filterload - 创建带有初始设置的布隆过滤器。布隆过滤器只返回我们感兴趣的交易的区块</p></li>
<li>
<p class='with-space'>getdata - 请求特定对象。交易、区块、默克尔区块或共识报文中有响应信息。</p></li>
<li>
<p class='with-space'>GetHeaders - 请求区块头</p></li>
<li>
<p class='with-space'>headers - 对getHeaders的响应</p></li>
<li>
<p class='with-space'>inv - 发送有关交易、区块或共识的信息</p></li>
<li>
<p class='with-space'>mempool - 请求内存池中已验证的交易。inv报文中带有响应信息</p></li>
<li>
<p class='with-space'>ping - 检查节点是否处于活跃状态</p></li>
<li>
<p class='with-space'>pong - 对ping消息的响应</p></li>
<li>
<p class='with-space'>tx - 对getData消息的响应</p></li>
</ul>
<p class='with-space'>要编写NEO ping报文，必须知道待发布的命令是有严格的顺序要求的。对于每个连接，version及其应答verack需要进行两次握手通信：一次从你的节点发出，一次从远程节点发出。以下流程图显示了这个命令序列：</p>
<figure class='highlight'>
<button type='button' class='btn-clipboard' data-original-title='Copy to clipboard' data-clipboard-action='copy' data-toggle='tooltip' data-placement='top' title='Copy to clipboard' data-clipboard-text='+-------+             +-------+
| NEO1  |             | NEO2  |
+-------+             +-------+
    |                     |
    | 命令version     |
    |--------------------&gt;|
    |                     |
    |     命令version |
    |&lt;--------------------|
    |                     |
    | 命令verack      |
    |--------------------&gt;|
    |                     |
    |      命令verack |
    |&lt;--------------------|
    |                     |
    | 命令ping        |
    |--------------------&gt;|
    |                     |
    |        命令pong |
    |&lt;--------------------|
    |                     |'>Copy</button><pre><code>+-------+             +-------+
| NEO1  |             | NEO2  |
+-------+             +-------+
    |                     |
    | 命令version     |
    |--------------------&gt;|
    |                     |
    |     命令version |
    |&lt;--------------------|
    |                     |
    | 命令verack      |
    |--------------------&gt;|
    |                     |
    |      命令verack |
    |&lt;--------------------|
    |                     |
    | 命令ping        |
    |--------------------&gt;|
    |                     |
    |        命令pong |
    |&lt;--------------------|
    |                     |
</code></pre>
</figure>
<p class='with-space'>对于NEO ping，我们只使用带有payload的version和ping命令。verack命令不带有任何的payload，这里不做说明。这两个命令的payload定义如下：</p>
<h3 id='e824f80c'><span class='with-space bd-content-title'>“version”命令<a class='anchorjs-link ' href='#e824f80c' aria-label='Anchor' data-anchorjs-icon='#'></a></span></h3>
<ul class='with-space'>
<li>
<p class='with-space'>version（uint32）指定协议的版本，当前版本为0。</p></li>
<li>
<p class='with-space'>Services（uint64）- 指定服务，当前设置为1</p></li>
<li>
<p class='with-space'>Timestamp（uint32）- 自1970年1月1日起经过的时间（单位：秒）</p></li>
<li>
<p class='with-space'>Port（uint16）- 监听的端口号，如果节点不处理传入连接，可以设为0</p></li>
<li>
<p class='with-space'>Nonce（uint32）- 随机数</p></li>
<li>
<p class='with-space'>Useragent 最多1024 字节- 本教程使用1字节长，字符串的格式。不要超过253字节（0xfd）</p></li>
<li>
<p class='with-space'>Blockheight（uint32）- 区块高度，你的区块高度可以是0</p></li>
<li>
<p class='with-space'>Relay（uint8）- 如果是中继节点，则设置为false（0）</p></li>
</ul>
<h3 id='af78e449'><span class='with-space bd-content-title'>“ping”命令<a class='anchorjs-link ' href='#af78e449' aria-label='Anchor' data-anchorjs-icon='#'></a></span></h3>
<ul class='with-space'>
<li>
<p class='with-space'>Blockheight（uint32）- 区块高度，你的区块高度可以是0</p></li>
<li>
<p class='with-space'>Timestamp（uint32）- 自1970年1月1日起经过的时间（单位：秒）</p></li>
<li>
<p class='with-space'>Nonce（uint32）- 随机数</p></li>
</ul>
<h3 id='dfe67ae8'><span class='with-space bd-content-title'>协议<a class='anchorjs-link ' href='#dfe67ae8' aria-label='Anchor' data-anchorjs-icon='#'></a></span></h3>
<p class='with-space'>利用这些信息，我们就可以实现NEO节点的ping命令。首先，我们需要编写针对version/ping的payload的编码器和解码器。</p>
<hr />
<p class='with-space'> <strong>练习3</strong> : 编写用于ping/version命令的编码器和解码器。使用 <a href='https://github.com/tbocek/vss-neo-tutorial/blob/master/neo-ping-template.go' target='_blank'> https://github.com/tbocek/vss-neo-tutorial/blob/master/neo-ping-template.go</a> 提供的模板实现以下两个功能：一个是 <code>encodeversion（useragent string）[]byte</code> ， <code>encodeping（）[]byte</code> ， <code>decodeversion（b[]byte）string</code> ，返回用户代理；另一个是 <code>decodePing（b[]byte）</code> 。在解码器中将相关信息输出到控制台。</p>
<p class='with-space'>提示：timestamp可以编码为：</p>
<figure class='highlight'>
<button type='button' class='btn-clipboard' data-original-title='Copy to clipboard' data-clipboard-action='copy' data-toggle='tooltip' data-placement='top' title='Copy to clipboard' data-clipboard-text='binary.LittleEndian.PutUint32(b[12:], uint32(time.Now().Unix()))'>Copy</button><pre><code>binary.LittleEndian.PutUint32(b[12:], uint32(time.Now().Unix()))
</code></pre>
</figure>
<p class='with-space'>解码为: <code>` fmt.Printf(&quot;time: %v\n&quot;, time.Unix(int64(binary.LittleEndian.Uint32(b[12:])), 0))</code> `</p>
<hr />
<h3 id='b6aea50a'><span class='with-space bd-content-title'>进行组装<a class='anchorjs-link ' href='#b6aea50a' aria-label='Anchor' data-anchorjs-icon='#'></a></span></h3>
<p class='with-space'>首先，连接到支持ping/pong命令的NEO节点。后面我们会检查版本的正确性：</p>
<figure class='highlight'>
<button type='button' class='btn-clipboard' data-original-title='Copy to clipboard' data-clipboard-action='copy' data-toggle='tooltip' data-placement='top' title='Copy to clipboard' data-clipboard-text='func main() {
    remote, err := net.Dial(&quot;tcp&quot;, &quot;node1.plutolo.gy:10333&quot;) // check: http://monitor.cityofzion.io/
    if err != nil {
        panic(err)
    }
    defer remote.Close()
    fmt.Println(&quot;Conneced to: %v&quot;, remote.RemoteAddr())'>Copy</button><pre><code>func main() {
    remote, err := net.Dial(&quot;tcp&quot;, &quot;node1.plutolo.gy:10333&quot;) // check: http://monitor.cityofzion.io/
    if err != nil {
        panic(err)
    }
    defer remote.Close()
    fmt.Println(&quot;Conneced to: %v&quot;, remote.RemoteAddr())
</code></pre>
</figure>
<p class='with-space'>现在我们发送version信息到远程的NEO节点。</p>
<figure class='highlight'>
<button type='button' class='btn-clipboard' data-original-title='Copy to clipboard' data-clipboard-action='copy' data-toggle='tooltip' data-placement='top' title='Copy to clipboard' data-clipboard-text='    payloadVersion := encodeVersion(&quot;/Our NEO client:0.0.1/&quot;)
    packetVersion := encodeHeader(&quot;version&quot;, payloadVersion)
    n, err := remote.Write(packetVersion)
    if err != nil {
        panic(err)
    }
    fmt.Printf(&quot;wrote version packet: %v, %d\n&quot;, packetVersion, n)'>Copy</button><pre><code>    payloadVersion := encodeVersion(&quot;/Our NEO client:0.0.1/&quot;)
    packetVersion := encodeHeader(&quot;version&quot;, payloadVersion)
    n, err := remote.Write(packetVersion)
    if err != nil {
        panic(err)
    }
    fmt.Printf(&quot;wrote version packet: %v, %d\n&quot;, packetVersion, n)
</code></pre>
</figure>
<p class='with-space'>发送了version，现在我们可以等远程主机发送version。实际上，一些客户端也会在连接建立后立即发送version信息。</p>
<figure class='highlight'>
<button type='button' class='btn-clipboard' data-original-title='Copy to clipboard' data-clipboard-action='copy' data-toggle='tooltip' data-placement='top' title='Copy to clipboard' data-clipboard-text='    //获取远程节点的版本，并显示
    read := make([]byte, 24)
    n, err = io.ReadFull(remote, read) //读取报头
    plen,rcvChecksum := decodeHeader(read)
    read = make([]byte, plen)
    n, err = io.ReadFull(remote, read) //读取payload
    userAgent := decodeVersion(read)'>Copy</button><pre><code>    //获取远程节点的版本，并显示
    read := make([]byte, 24)
    n, err = io.ReadFull(remote, read) //读取报头
    plen,rcvChecksum := decodeHeader(read)
    read = make([]byte, plen)
    n, err = io.ReadFull(remote, read) //读取payload
    userAgent := decodeVersion(read)
</code></pre>
</figure>
<p class='with-space'>在接收到NEO节点的版本信息时，我们还会额外检查校验和是否匹配。校验和是payload的两次SHA256哈希后结果的前4个字节。</p>
<figure class='highlight'>
<button type='button' class='btn-clipboard' data-original-title='Copy to clipboard' data-clipboard-action='copy' data-toggle='tooltip' data-placement='top' title='Copy to clipboard' data-clipboard-text='    tmp := sha256.Sum256(read)
    hash := sha256.Sum256(tmp[:])
    checksum := binary.LittleEndian.Uint32(hash[0:4])
    fmt.Printf(&quot;read version payload: %v, %d\n&quot;, read, n)
    if rcvChecksum != checksum {
        panic(errors.New(&quot;checksum mismatch in version!&quot;))
    }'>Copy</button><pre><code>    tmp := sha256.Sum256(read)
    hash := sha256.Sum256(tmp[:])
    checksum := binary.LittleEndian.Uint32(hash[0:4])
    fmt.Printf(&quot;read version payload: %v, %d\n&quot;, read, n)
    if rcvChecksum != checksum {
        panic(errors.New(&quot;checksum mismatch in version!&quot;))
    }
</code></pre>
</figure>
<p class='with-space'>由于ping/pong是最近才实现的，因此我们需要确保我们的版本是否支持这个功能。看起来版本使用了语义版本控制。但是，Python实现使用了不同的版本控制，因此我们还应该检查使用了哪个用户代理。由于还没有高于v2.10.1的实现版本，因此我们只需检查这个版本（快速而粗糙：）。</p>
<figure class='highlight'>
<button type='button' class='btn-clipboard' data-original-title='Copy to clipboard' data-clipboard-action='copy' data-toggle='tooltip' data-placement='top' title='Copy to clipboard' data-clipboard-text='    //检查版本是否正确
    start := strings.Index(userAgent, &quot;:&quot;)
    end := strings.Index(userAgent[start:], &quot;/&quot;)
    if start &lt; 0 &amp;&amp; end &lt; 0 {
        panic(errors.New(fmt.Sprintf(&quot;cannot parse version in %s&quot;, userAgent)))
    }
    semVer := userAgent[start+1:start+end]
    fmt.Printf(&quot;parsed semver: %v\n&quot;, semVer)
    v1, err := version.NewVersion(semVer)
    min, err := version.NewVersion(&quot;2.10.1&quot;)
    if v1.LessThan(min) {
        panic(errors.New(fmt.Sprintf(&quot;%s is less than %s&quot;, v1, min)))
    }'>Copy</button><pre><code>    //检查版本是否正确
    start := strings.Index(userAgent, &quot;:&quot;)
    end := strings.Index(userAgent[start:], &quot;/&quot;)
    if start &lt; 0 &amp;&amp; end &lt; 0 {
        panic(errors.New(fmt.Sprintf(&quot;cannot parse version in %s&quot;, userAgent)))
    }
    semVer := userAgent[start+1:start+end]
    fmt.Printf(&quot;parsed semver: %v\n&quot;, semVer)
    v1, err := version.NewVersion(semVer)
    min, err := version.NewVersion(&quot;2.10.1&quot;)
    if v1.LessThan(min) {
        panic(errors.New(fmt.Sprintf(&quot;%s is less than %s&quot;, v1, min)))
    }
</code></pre>
</figure>
<p class='with-space'>由于我们发送了一个version数据包，所以我们需要接收一个verack包，而又由于我们也收到了version包，所以我们还需要发送回verack：</p>
<figure class='highlight'>
<button type='button' class='btn-clipboard' data-original-title='Copy to clipboard' data-clipboard-action='copy' data-toggle='tooltip' data-placement='top' title='Copy to clipboard' data-clipboard-text='    ////////// 获取version，发送verack
    packetVerack := encodeHeader(&quot;verack&quot;, []byte{})
    n, err = remote.Write(packetVerack);
    if err != nil {
        panic(err)
    }

    ///////// 等待verack 确认
    read = make([]byte, 24)
    n, err = io.ReadFull(remote, read)
    plen, rcvChecksum = decodeHeader(read)
    fmt.Printf(&quot;read verack array: %v, %d\n&quot;, read, plen)
    if rcvChecksum != 3806393949 {
        panic(errors.New(&quot;checksum mismatch in verack!&quot;))
    }'>Copy</button><pre><code>    ////////// 获取version，发送verack
    packetVerack := encodeHeader(&quot;verack&quot;, []byte{})
    n, err = remote.Write(packetVerack);
    if err != nil {
        panic(err)
    }

    ///////// 等待verack 确认
    read = make([]byte, 24)
    n, err = io.ReadFull(remote, read)
    plen, rcvChecksum = decodeHeader(read)
    fmt.Printf(&quot;read verack array: %v, %d\n&quot;, read, plen)
    if rcvChecksum != 3806393949 {
        panic(errors.New(&quot;checksum mismatch in verack!&quot;))
    }
</code></pre>
</figure>
<p class='with-space'>在version/verack之后，现在我们可以发送ping了。没有这些versions信息，就不能发送任何命令</p>
<figure class='highlight'>
<button type='button' class='btn-clipboard' data-original-title='Copy to clipboard' data-clipboard-action='copy' data-toggle='tooltip' data-placement='top' title='Copy to clipboard' data-clipboard-text='    /////// 发送ping
    packet2 := encodeHeader(&quot;ping&quot;, encodePing())
    n, err = remote.Write(packet2)
    if err != nil {
        panic(err)
    }
    fmt.Printf(&quot;wrote ping: %v, %d\n&quot;, packet2, n)'>Copy</button><pre><code>    /////// 发送ping
    packet2 := encodeHeader(&quot;ping&quot;, encodePing())
    n, err = remote.Write(packet2)
    if err != nil {
        panic(err)
    }
    fmt.Printf(&quot;wrote ping: %v, %d\n&quot;, packet2, n)
</code></pre>
</figure>
<p class='with-space'>发送ping之后，我们可以期待接收到一个pong报文。</p>
<figure class='highlight'>
<button type='button' class='btn-clipboard' data-original-title='Copy to clipboard' data-clipboard-action='copy' data-toggle='tooltip' data-placement='top' title='Copy to clipboard' data-clipboard-text='    //////// 收到pong
    read = make([]byte, 36)
    _, err = io.ReadFull(remote, read)
    _, rcvChecksum = decodeHeader(read)
    decodePing(read[24 : 24+12])
    fmt.Printf(&quot;read array: %v\n&quot;, read)

    tmp = sha256.Sum256(read[24 : 24+12])
    hash = sha256.Sum256(tmp[:])
    checksum = binary.LittleEndian.Uint32(hash[0:4])

    if rcvChecksum != checksum {
        panic(errors.New(&quot;checksum mismatch in pong!&quot;))
    }

    remote.Close()
}'>Copy</button><pre><code>    //////// 收到pong
    read = make([]byte, 36)
    _, err = io.ReadFull(remote, read)
    _, rcvChecksum = decodeHeader(read)
    decodePing(read[24 : 24+12])
    fmt.Printf(&quot;read array: %v\n&quot;, read)

    tmp = sha256.Sum256(read[24 : 24+12])
    hash = sha256.Sum256(tmp[:])
    checksum = binary.LittleEndian.Uint32(hash[0:4])

    if rcvChecksum != checksum {
        panic(errors.New(&quot;checksum mismatch in pong!&quot;))
    }

    remote.Close()
}
</code></pre>
</figure>
<hr />
<p class='with-space'> <strong>练习4</strong> : 利用模板将编码器/解码器代码与main函数进行合并，并在主网上运行。你能看到什么？</p>
<p class='with-space'>在成功发送NEO ping并接收到返回的pong之后，我们可以发送 <code>getaddr</code> 并获取更多NEO网络中的节点信息。这样你就可以使用已经建立的连接了。对于P2P和分布式系统来说，寻找其他对等节点至关重要，因为节点随时可能下线，需要连接到其他节点。</p>
<hr />
<p class='with-space'> <strong>练习5</strong> : 发送完ping报文后，发送 <code>getaddr</code> 报文。分析输出。</p>
<p class='with-space'>提示：输出包含一个IP地址列表（16字节长的IPv6/4，2字节长的端口），这些地址是经过大端编码的。数据还包含一个service标志位（设置为1）和一个时间戳timestamp。</p>
<p class='with-space'>现在，你已经成功地实现了一个NEO客户端，它可以建立一个到其他NEO节点的连接，发送ping命令，接收pong命令以及获取更多节点的列表。</p>
<hr />
<h2 id='f4cddbe4'><span class='with-space bd-content-title'>附录A：快速而粗糙的模板<a class='anchorjs-link ' href='#f4cddbe4' aria-label='Anchor' data-anchorjs-icon='#'></a></span></h2>
<figure class='highlight'>
<button type='button' class='btn-clipboard' data-original-title='Copy to clipboard' data-clipboard-action='copy' data-toggle='tooltip' data-placement='top' title='Copy to clipboard' data-clipboard-text='package main

import (
    &quot;bytes&quot;
    //&quot;bytes&quot;
    &quot;crypto/sha256&quot;
    &quot;encoding/binary&quot;
    &quot;errors&quot;
    &quot;fmt&quot;
    &quot;github.com/hashicorp/go-version&quot;
    &quot;io&quot;
    //&quot;math/rand&quot;
    &quot;net&quot;
    &quot;strings&quot;
    //&quot;time&quot;
)

func main() {
    remote, err := net.Dial(&quot;tcp&quot;, &quot;node1.plutolo.gy:10333&quot;) //check: http://monitor.cityofzion.io/
    if err != nil {
        panic(err)
    }
    defer remote.Close()
    fmt.Println(&quot;Conneced to: %v&quot;, remote.RemoteAddr())

    payloadVersion := encodeVersion(&quot;/The HSR NEO client:0.0.1/&quot;)
    packetVersion := encodeHeader(&quot;version&quot;, payloadVersion)
    n, err := remote.Write(packetVersion)
    if err != nil {
        panic(err)
    }
    fmt.Printf(&quot;wrote version packet: %v, %d\n&quot;, packetVersion, n)

    //从远程节点获得version，并加以显示
    read := make([]byte, 24)
    n, err = io.ReadFull(remote, read) //读取报头
    plen, rcvChecksum := decodeHeader(read)
    read = make([]byte, plen)
    n, err = io.ReadFull(remote, read) //读取payload
    userAgent := decodeVersion(read)

    tmp := sha256.Sum256(read)
    hash := sha256.Sum256(tmp[:])
    checksum := binary.LittleEndian.Uint32(hash[0:4])
    fmt.Printf(&quot;read version payload: %v, %d\n&quot;, read, n)
    if rcvChecksum != checksum {
        panic(errors.New(&quot;checksum mismatch in version!&quot;))
    }

    //检验版本是否正确
    start := strings.Index(userAgent, &quot;:&quot;)
    end := strings.Index(userAgent[start:], &quot;/&quot;)
    if start &lt; 0 &amp;&amp; end &lt; 0 {
        panic(errors.New(fmt.Sprintf(&quot;cannot parse version in %s&quot;, userAgent)))
    }
    semVer := userAgent[start+1 : start+end]
    fmt.Printf(&quot;parsed semver: %v\n&quot;, semVer)
    v1, err := version.NewVersion(semVer)
    min, err := version.NewVersion(&quot;2.10.1&quot;)
    if v1.LessThan(min) {
        panic(errors.New(fmt.Sprintf(&quot;%s is less than %s&quot;, v1, min)))
    }

    ////////// 收到version, 发送verack
    packetVerack := encodeHeader(&quot;verack&quot;, []byte{})
    n, err = remote.Write(packetVerack)
    if err != nil {
        panic(err)
    }

    ///////// 等到verack 确认
    read = make([]byte, 24)
    n, err = io.ReadFull(remote, read)
    plen, rcvChecksum = decodeHeader(read)
    fmt.Printf(&quot;read verack array: %v, %d\n&quot;, read, plen)
    if rcvChecksum != 3806393949 {
        panic(errors.New(&quot;checksum mismatch in verack!&quot;))
    }

    /////// 发送ping
    packet2 := encodeHeader(&quot;ping&quot;, encodePing())
    n, err = remote.Write(packet2)
    if err != nil {
        panic(err)
    }
    fmt.Printf(&quot;wrote ping: %v, %d\n&quot;, packet2, n)

    //////// 接收pong
    read = make([]byte, 36)
    _, err = io.ReadFull(remote, read)
    _, rcvChecksum = decodeHeader(read)
    decodePing(read[24 : 24+12])
    fmt.Printf(&quot;read array: %v\n&quot;, read)

    tmp = sha256.Sum256(read[24 : 24+12])
    hash = sha256.Sum256(tmp[:])
    checksum = binary.LittleEndian.Uint32(hash[0:4])

    if rcvChecksum != checksum {
        panic(errors.New(&quot;checksum mismatch in pong!&quot;))
    }

    remote.Close()
}

func encodeHeader(cmd string, payload []byte) []byte {
    b := make([]byte, 24+len(payload))

    binary.LittleEndian.PutUint32(b[0:], 0x00746E41)
    //此处进行编码
    copy(b[4:], cmd)
    //payload长度
    binary.LittleEndian.PutUint32(b[16:], uint32(len(payload)))
    //payload校验和
    tmp := sha256.Sum256(payload)
    hash := sha256.Sum256(tmp[:])
    copy(b[20:], hash[0:4])

    //payload
    copy(b[24:], payload)
    return b
}

func encodeVersion(userAgent string) []byte {
    userAgentLen := len(userAgent)
    b := make([]byte, 27+userAgentLen+1)
    // 此处进行编码
    b[27+userAgentLen] = 0
    return b
}

func encodePing() []byte {
    b := make([]byte, 12)
    // 此处进行编码
    return b
}

func decodeHeader(b []byte) (uint32, uint32) {
    fmt.Printf(&quot;magic: 0x%x\n&quot;, binary.LittleEndian.Uint32(b))
    fmt.Printf(&quot;command: %v\n&quot;, string(bytes.Trim(b[4:16], &quot;\x00&quot;)))
    len := binary.LittleEndian.Uint32(b[16:])
    fmt.Printf(&quot;payload len: %d\n&quot;, len)
    checksum := binary.LittleEndian.Uint32(b[20:])
    fmt.Printf(&quot;checksum: 0x%x\n&quot;, checksum)
    return len, checksum

}

func decodeVersion(b []byte) string {
    // 此处进行解码
    //返回userAgent

    return &quot;&quot;
}

func decodePing(b []byte) {
    // 此处进行解码
}'>Copy</button><pre><code class='go' lang='go'>package main

import (
    &quot;bytes&quot;
    //&quot;bytes&quot;
    &quot;crypto/sha256&quot;
    &quot;encoding/binary&quot;
    &quot;errors&quot;
    &quot;fmt&quot;
    &quot;github.com/hashicorp/go-version&quot;
    &quot;io&quot;
    //&quot;math/rand&quot;
    &quot;net&quot;
    &quot;strings&quot;
    //&quot;time&quot;
)

func main() {
    remote, err := net.Dial(&quot;tcp&quot;, &quot;node1.plutolo.gy:10333&quot;) //check: http://monitor.cityofzion.io/
    if err != nil {
        panic(err)
    }
    defer remote.Close()
    fmt.Println(&quot;Conneced to: %v&quot;, remote.RemoteAddr())

    payloadVersion := encodeVersion(&quot;/The HSR NEO client:0.0.1/&quot;)
    packetVersion := encodeHeader(&quot;version&quot;, payloadVersion)
    n, err := remote.Write(packetVersion)
    if err != nil {
        panic(err)
    }
    fmt.Printf(&quot;wrote version packet: %v, %d\n&quot;, packetVersion, n)

    //从远程节点获得version，并加以显示
    read := make([]byte, 24)
    n, err = io.ReadFull(remote, read) //读取报头
    plen, rcvChecksum := decodeHeader(read)
    read = make([]byte, plen)
    n, err = io.ReadFull(remote, read) //读取payload
    userAgent := decodeVersion(read)

    tmp := sha256.Sum256(read)
    hash := sha256.Sum256(tmp[:])
    checksum := binary.LittleEndian.Uint32(hash[0:4])
    fmt.Printf(&quot;read version payload: %v, %d\n&quot;, read, n)
    if rcvChecksum != checksum {
        panic(errors.New(&quot;checksum mismatch in version!&quot;))
    }

    //检验版本是否正确
    start := strings.Index(userAgent, &quot;:&quot;)
    end := strings.Index(userAgent[start:], &quot;/&quot;)
    if start &lt; 0 &amp;&amp; end &lt; 0 {
        panic(errors.New(fmt.Sprintf(&quot;cannot parse version in %s&quot;, userAgent)))
    }
    semVer := userAgent[start+1 : start+end]
    fmt.Printf(&quot;parsed semver: %v\n&quot;, semVer)
    v1, err := version.NewVersion(semVer)
    min, err := version.NewVersion(&quot;2.10.1&quot;)
    if v1.LessThan(min) {
        panic(errors.New(fmt.Sprintf(&quot;%s is less than %s&quot;, v1, min)))
    }

    ////////// 收到version, 发送verack
    packetVerack := encodeHeader(&quot;verack&quot;, []byte{})
    n, err = remote.Write(packetVerack)
    if err != nil {
        panic(err)
    }

    ///////// 等到verack 确认
    read = make([]byte, 24)
    n, err = io.ReadFull(remote, read)
    plen, rcvChecksum = decodeHeader(read)
    fmt.Printf(&quot;read verack array: %v, %d\n&quot;, read, plen)
    if rcvChecksum != 3806393949 {
        panic(errors.New(&quot;checksum mismatch in verack!&quot;))
    }

    /////// 发送ping
    packet2 := encodeHeader(&quot;ping&quot;, encodePing())
    n, err = remote.Write(packet2)
    if err != nil {
        panic(err)
    }
    fmt.Printf(&quot;wrote ping: %v, %d\n&quot;, packet2, n)

    //////// 接收pong
    read = make([]byte, 36)
    _, err = io.ReadFull(remote, read)
    _, rcvChecksum = decodeHeader(read)
    decodePing(read[24 : 24+12])
    fmt.Printf(&quot;read array: %v\n&quot;, read)

    tmp = sha256.Sum256(read[24 : 24+12])
    hash = sha256.Sum256(tmp[:])
    checksum = binary.LittleEndian.Uint32(hash[0:4])

    if rcvChecksum != checksum {
        panic(errors.New(&quot;checksum mismatch in pong!&quot;))
    }

    remote.Close()
}

func encodeHeader(cmd string, payload []byte) []byte {
    b := make([]byte, 24+len(payload))

    binary.LittleEndian.PutUint32(b[0:], 0x00746E41)
    //此处进行编码
    copy(b[4:], cmd)
    //payload长度
    binary.LittleEndian.PutUint32(b[16:], uint32(len(payload)))
    //payload校验和
    tmp := sha256.Sum256(payload)
    hash := sha256.Sum256(tmp[:])
    copy(b[20:], hash[0:4])

    //payload
    copy(b[24:], payload)
    return b
}

func encodeVersion(userAgent string) []byte {
    userAgentLen := len(userAgent)
    b := make([]byte, 27+userAgentLen+1)
    // 此处进行编码
    b[27+userAgentLen] = 0
    return b
}

func encodePing() []byte {
    b := make([]byte, 12)
    // 此处进行编码
    return b
}

func decodeHeader(b []byte) (uint32, uint32) {
    fmt.Printf(&quot;magic: 0x%x\n&quot;, binary.LittleEndian.Uint32(b))
    fmt.Printf(&quot;command: %v\n&quot;, string(bytes.Trim(b[4:16], &quot;\x00&quot;)))
    len := binary.LittleEndian.Uint32(b[16:])
    fmt.Printf(&quot;payload len: %d\n&quot;, len)
    checksum := binary.LittleEndian.Uint32(b[20:])
    fmt.Printf(&quot;checksum: 0x%x\n&quot;, checksum)
    return len, checksum

}

func decodeVersion(b []byte) string {
    // 此处进行解码
    //返回userAgent

    return &quot;&quot;
}

func decodePing(b []byte) {
    // 此处进行解码
}
</code></pre>
</figure>
<h2 id='e6b23da9'><span class='with-space bd-content-title'>阅读下节<a class='anchorjs-link ' href='#e6b23da9' aria-label='Anchor' data-anchorjs-icon='#'></a></span></h2>
<p class='with-space'> <a href='../6-persistence/1-persistence.html'> 持久化</a> </p>
            </main>
            <div class="d-none d-lg-block side-nav py-2 py-md-5">
                <a href="https://github.com/neo-project/docs/blob/master/tutorial/zh-cn/5-network\1-Introduction_to_the_NEO_network_protocol.md" class="contribution-link d-block">Improve this Doc</a>
                <div class="side-nav-text">In this article</div>
                <div id="navbar-sidenav">
                    <nav class='nav nav-pills flex-column'>
<a class='ml--2 d-none my-1 nav-link' href='#ed93e18f'>NEO 协议和网络</a>
<nav class='nav nav-pills flex-column'>
<a class='ml-0 my-1 nav-link' href='#a3cedf5f'>使用Golang来Ping NEO 网络</a>
<nav class='nav nav-pills flex-column'>
<a class='ml-2 my-1 nav-link' href='#dccff549'>小端和大端</a>
<a class='ml-2 my-1 nav-link' href='#f625f1fe'>校验和</a>
<a class='ml-2 my-1 nav-link' href='#d0048a33'>Payload协议</a>
<a class='ml-2 my-1 nav-link' href='#e824f80c'>“version”命令</a>
<a class='ml-2 my-1 nav-link' href='#af78e449'>“ping”命令</a>
<a class='ml-2 my-1 nav-link' href='#dfe67ae8'>协议</a>
<a class='ml-2 my-1 nav-link' href='#b6aea50a'>进行组装</a>
</nav>
<a class='ml-0 my-1 nav-link' href='#f4cddbe4'>附录A：快速而粗糙的模板</a>
<a class='ml-0 my-1 nav-link' href='#e6b23da9'>阅读下节</a>
</nav>
</nav>
                </div>
            </div>
        </div>
    </div>
    <div class="lightbulb" title="Turn On/Off" onclick="turnOff()">
        <i class="far fa-lightbulb"></i>
    </div>
    <footer>
        <div class="d-flex justify-content-between py-1 px-3 px-sm-4 px-md-5">
            <ul class="d-none d-md-block">
                <li><a href="https://github.com/neo-project/docs" title="GitHub" target="_blank">GitHub</a></li>
                <li><a href="https://github.com/neo-project/docs/issues" title="Issue" target="_blank">Issue</a></li>
                <li><a href="https://discord.io/neo" title="Discord" target="_blank">Discord</a></li>
            </ul>
            <p>Build by <a href="https://github.com/chenzhitong/NeoDocsBuilder" title="NeoDocsBuilder" target="_blank">NeoDocsBuilder</a></p>
            <p>Licensed under <a href="https://github.com/neo-project/docs/blob/master/LICENSE" title="CC-BY-4.0" target="_blank">CC-BY-4.0</a> license. </p>
        </div>
    </footer>
    <script src="https://neo-cdn.azureedge.net/lib/jquery/jquery.min.js"></script>
    <script src="https://neo-cdn.azureedge.net/lib/popper.js/popper.min.js"></script>
    <script src="https://neo-cdn.azureedge.net/lib/bootstrap/js/bootstrap.min.js"></script>
    <script src="https://neo-cdn.azureedge.net/js/jquery.lazyload.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.8/highlight.min.js"></script>
    <script src="https://neo-cdn.azureedge.net/js/text-autospace.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js"></script>
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-130525731-2"></script>
    <script src="/js/site.min.js"></script>
    <script>
        //适用于FAQ的根据标题展开收缩
        if (false) {
            $("h2").click(function (e) {
                $(".div-collapse").not($(e.target).parents("h2").next()).hide("fast");
                $(e.target).parents("h2").next().toggle("fast");
            });
        }
    </script>
</body>
</html>
